From 3704e0cf1ba8d0bcd34b3f14c6baa659bb95a0a5 Mon Sep 17 00:00:00 2001
From: Olivier Brunel <jjk@jjacky.com>
Date: Tue, 15 Oct 2013 15:09:32 +0200
Subject: [PATCH 3/3] treeview: Add GtkTreeBoxable

When a model implements GtkTreeBoxable, the GtkTreeView will do some special
drawing when rendering, to allow the creation of a "boxed branch" effect.

That is, when a row is "boxed" a different background color will be used for the
row & all its children (Note that the tree only adds region & class, it's up
to the CSS to actually set background colors to prodice the effect).

The region BOXED is added to the part in the expander area, so it can be made
always visible (above focus/selection/etc) so the boxed effect is never
lost/hidden.

Signed-off-by: Olivier Brunel <jjk@jjacky.com>
---
 docs/reference/gtk/gtk-docs.sgml     |   1 +
 docs/reference/gtk/gtk3-sections.txt |  21 +++
 docs/reference/gtk/gtk3.types.in     |   1 +
 gtk/Makefile.am                      |   2 +
 gtk/gtk.h                            |   1 +
 gtk/gtkstylecontext.h                |  12 ++
 gtk/gtktreeboxable.c                 | 246 ++++++++++++++++++++++++++
 gtk/gtktreeboxable.h                 | 103 +++++++++++
 gtk/gtktreestore.c                   | 331 ++++++++++++++++++++++++++++++++++-
 gtk/gtktreestore.h                   |   1 +
 gtk/gtktreeview.c                    | 159 ++++++++++++++++-
 11 files changed, 866 insertions(+), 12 deletions(-)
 create mode 100644 gtk/gtktreeboxable.c
 create mode 100644 gtk/gtktreeboxable.h

diff --git a/docs/reference/gtk/gtk-docs.sgml b/docs/reference/gtk/gtk-docs.sgml
index a33797d..e61c1e8 100644
--- a/docs/reference/gtk/gtk-docs.sgml
+++ b/docs/reference/gtk/gtk-docs.sgml
@@ -149,6 +149,7 @@
       <xi:include href="xml/gtktreednd.xml" />
       <xi:include href="xml/gtkcellview.xml" />
       <xi:include href="xml/gtkiconview.xml" />
+      <xi:include href="xml/gtktreeboxable.xml" />
       <xi:include href="xml/gtktreesortable.xml" />
       <xi:include href="xml/gtktreemodelsort.xml" />
       <xi:include href="xml/gtktreemodelfilter.xml" />
diff --git a/docs/reference/gtk/gtk3-sections.txt b/docs/reference/gtk/gtk3-sections.txt
index ef74efa..46ed062 100644
--- a/docs/reference/gtk/gtk3-sections.txt
+++ b/docs/reference/gtk/gtk3-sections.txt
@@ -4262,6 +4262,27 @@ gtk_tooltip_get_type
 </SECTION>
 
 <SECTION>
+<FILE>gtktreeboxable</FILE>
+<TITLE>GtkTreeBoxable</TITLE>
+GtkTreeBoxable
+GtkTreeBoxableInterface
+gtk_tree_boxable_box_column_changed
+gtk_tree_boxable_get_box_column
+gtk_tree_boxable_set_box_column
+gtk_tree_boxable_get_current_box_info
+gtk_tree_boxable_get_in_box_info
+gtk_tree_boxable_get_main_box_info
+<SUBSECTION Standard>
+GTK_TREE_BOXABLE
+GTK_IS_TREE_BOXABLE
+GTK_TYPE_TREE_BOXABLE
+GTK_TREE_BOXABLE_CLASS
+GTK_TREE_BOXABLE_GET_IFACE
+<SUBSECTION Private>
+gtk_tree_boxable_get_type
+</SECTION>
+
+<SECTION>
 <FILE>gtktreemodel</FILE>
 <TITLE>GtkTreeModel</TITLE>
 GtkTreeModel
diff --git a/docs/reference/gtk/gtk3.types.in b/docs/reference/gtk/gtk3.types.in
index 609f54b..133ac9e 100644
--- a/docs/reference/gtk/gtk3.types.in
+++ b/docs/reference/gtk/gtk3.types.in
@@ -190,6 +190,7 @@ gtk_tool_button_get_type
 gtk_tool_item_get_type
 gtk_tool_item_group_get_type
 gtk_tool_palette_get_type
+gtk_tree_boxable_get_type
 gtk_tree_drag_dest_get_type
 gtk_tree_drag_source_get_type
 gtk_tree_model_filter_get_type
diff --git a/gtk/Makefile.am b/gtk/Makefile.am
index c281666..b8559dd 100644
--- a/gtk/Makefile.am
+++ b/gtk/Makefile.am
@@ -384,6 +384,7 @@ gtk_public_h_sources = 		\
 	gtktreemodelsort.h	\
 	gtktreeselection.h	\
 	gtktreesortable.h	\
+	gtktreeboxable.h	\
 	gtktreestore.h		\
 	gtktreeview.h		\
 	gtktreeviewcolumn.h	\
@@ -905,6 +906,7 @@ gtk_base_c_sources = 		\
 	gtktreemodelsort.c	\
 	gtktreeselection.c	\
 	gtktreesortable.c	\
+	gtktreeboxable.c	\
 	gtktreestore.c		\
 	gtktreeview.c		\
 	gtktreeviewcolumn.c	\
diff --git a/gtk/gtk.h b/gtk/gtk.h
index 16357c1..28f2f9a 100644
--- a/gtk/gtk.h
+++ b/gtk/gtk.h
@@ -206,6 +206,7 @@
 #include <gtk/gtktoolshell.h>
 #include <gtk/gtktooltip.h>
 #include <gtk/gtktestutils.h>
+#include <gtk/gtktreeboxable.h>
 #include <gtk/gtktreednd.h>
 #include <gtk/gtktreemodel.h>
 #include <gtk/gtktreemodelfilter.h>
diff --git a/gtk/gtkstylecontext.h b/gtk/gtkstylecontext.h
index 1bab439..d7273b6 100644
--- a/gtk/gtkstylecontext.h
+++ b/gtk/gtkstylecontext.h
@@ -796,6 +796,18 @@ struct _GtkStyleContextClass
 #define GTK_STYLE_REGION_ROW "row"
 
 /**
+ * GTK_STYLE_REGION_BOXED:
+ *
+ * A widget region name to define a treeview boxed area around the expander.
+ *
+ * This is the expander area (where expander & lines are drawn) that will be
+ * used to show the boxes (See #GtkTreeBoxable)
+ * It can be used to always show the boxed effect/color regardless of any other
+ * style, e.g. pseudo-class focused/selected.
+ */
+#define GTK_STYLE_REGION_BOXED "boxed"
+
+/**
  * GTK_STYLE_REGION_COLUMN:
  *
  * A widget region name to define a treeview column.
diff --git a/gtk/gtktreeboxable.c b/gtk/gtktreeboxable.c
new file mode 100644
index 0000000..64ec64e
--- /dev/null
+++ b/gtk/gtktreeboxable.c
@@ -0,0 +1,246 @@
+/* gtktreeboxable.c
+ * Copyright (C) 2013 Olivier Brunel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+#include "gtktreeboxable.h"
+#include "gtkmarshalers.h"
+#include "gtkintl.h"
+
+enum
+{
+  BOX_COLUMN_CHANGED,
+  NB_SIGNALS
+};
+
+/**
+ * SECTION:gtktreeboxable
+ * @Short_description: The interface for boxable models used by GtkTreeView
+ * @Title: GtkTreeBoxable
+ * @See_also: #GtkTreeModel, #GtkTreeView
+ *
+ * #GtkTreeBoxable is an interface to be implemented by tree models which
+ * support "boxing" nodes. The #GtkTreeView uses the box name as class name (to
+ * change background colors) to show the boxing effect.
+ */
+
+static guint gtk_tree_boxable_signals[NB_SIGNALS] = { 0, };
+
+static void
+gtk_tree_boxable_default_init (GtkTreeBoxableInterface *iface)
+{
+  gtk_tree_boxable_signals[BOX_COLUMN_CHANGED] =
+    /**
+     * GtkTreeBoxable::box_column_changed:
+     * @boxable: the #GtkTreeBoxable model on which the signal is emitted
+     *
+     * The ::box_column_changed signal is emitted when the box column of
+     * @boxable is changed.
+     */
+    g_signal_new("box-column-changed",
+                 GTK_TYPE_TREE_BOXABLE,
+                 G_SIGNAL_RUN_LAST,
+                 G_STRUCT_OFFSET (GtkTreeBoxableInterface, box_column_changed),
+                 NULL,
+                 NULL,
+                 _gtk_marshal_VOID__VOID,
+                 G_TYPE_NONE,
+                 0);
+}
+
+G_DEFINE_INTERFACE (GtkTreeBoxable, gtk_tree_boxable, GTK_TYPE_TREE_MODEL)
+
+/* signals */
+
+/**
+ * gtk_tree_boxable_box_column_changed:
+ * @boxable: A #GtkTreeBoxable model
+ *
+ * Emits a ::box_column_changed signal on @boxable
+ */
+void
+gtk_tree_boxable_box_column_changed (GtkTreeBoxable *boxable)
+{
+  g_return_if_fail (GTK_IS_TREE_BOXABLE (boxable));
+  g_signal_emit (boxable, gtk_tree_boxable_signals[BOX_COLUMN_CHANGED], 0);
+}
+
+/* API */
+
+/**
+ * gtk_tree_boxable_get_box_column:
+ * @boxable: A #GtkTreeBoxable model
+ *
+ * Returns the column id used as box-column, i.e. storing class names to be used
+ * to create the box effect, or -1 if none set.
+ *
+ * Returns: The box column id
+ */
+gint
+gtk_tree_boxable_get_box_column (GtkTreeBoxable *boxable)
+{
+  GtkTreeBoxableInterface *iface;
+
+  g_return_val_if_fail (GTK_IS_TREE_BOXABLE (boxable), FALSE);
+
+  iface = GTK_TREE_BOXABLE_GET_IFACE (boxable);
+
+  g_return_val_if_fail (iface != NULL, FALSE);
+  g_return_val_if_fail (iface->get_box_column != NULL, FALSE);
+
+  return (*iface->get_box_column) (boxable);
+}
+
+/**
+ * gtk_tree_boxable_set_box_column:
+ * @boxable: A #GtkTreeBoxable model
+ * @column: The column id to set
+ *
+ * Sets the box column to be @column. It must hold class names, which will be
+ * used by #GtkTreeView when rendering to create the box effect.
+ *
+ * Returns: %TRUE is @column was set as the new box column, else %FALSE
+ */
+gboolean
+gtk_tree_boxable_set_box_column (GtkTreeBoxable *boxable, gint column)
+{
+  GtkTreeBoxableInterface *iface;
+
+  g_return_val_if_fail (GTK_IS_TREE_BOXABLE (boxable), FALSE);
+
+  iface = GTK_TREE_BOXABLE_GET_IFACE (boxable);
+
+  g_return_val_if_fail (iface != NULL, FALSE);
+  g_return_val_if_fail (iface->set_box_column != NULL, FALSE);
+
+  return (*iface->set_box_column) (boxable, column);
+}
+
+/**
+ * gtk_tree_boxable_get_current_box_info:
+ * @boxable: A #GtkTreeBoxable model
+ * @box: Return location of a pointer for the class name of the current box
+ * @depth: Return location for the depth of the current box
+ * @iter: #GtkTreeIter of the row to get current box of
+ *
+ * Fills in @box and @depth with the box/class name and depth of the row pointed
+ * to by @iter.
+ * If the row isn't a box itself, %FALSE will be returned. To get info about the
+ * box the row is in, whether the box is on the row itself or a parent, see
+ * gtk_tree_boxable_get_main_box_info()
+ *
+ * Returns: %TRUE if @iter is a boxed row, else %FALSE
+ */
+gboolean
+gtk_tree_boxable_get_current_box_info (GtkTreeBoxable *boxable,
+                                       gchar         **box,
+                                       gint           *depth,
+                                       GtkTreeIter    *iter)
+{
+  GtkTreeBoxableInterface *iface;
+
+  g_return_val_if_fail (GTK_IS_TREE_BOXABLE (boxable), FALSE);
+  g_return_val_if_fail (box != NULL, FALSE);
+  g_return_val_if_fail (depth != NULL, FALSE);
+  g_return_val_if_fail (iter != NULL, FALSE);
+
+  iface = GTK_TREE_BOXABLE_GET_IFACE (boxable);
+
+  g_return_val_if_fail (iface != NULL, FALSE);
+  g_return_val_if_fail (iface->get_current_box_info != NULL, FALSE);
+
+  return (*iface->get_current_box_info) (boxable, box, depth, iter);
+}
+
+/**
+ * gtk_tree_boxable_get_in_box_info:
+ * @boxable: A #GtkTreeBoxable model
+ * @iter_box: A #GtkTreeIter that will be set to the boxed row
+ * @box: Return location of a pointer for the class name of the box
+ * @depth: Return location for the depth of the boxed row
+ * @iter: #GtkTreeIter of the row to get info for
+ *
+ * Fills in @box and @depth with the box/class name and depth of the first boxed
+ * parent of @iter. Location of said parent is set in @iter_box.
+ *
+ * To get info about the box status of the row itself, see
+ * gtk_tree_boxable_get_current_box_info()
+ *
+ * Returns: %TRUE if @iter has a boxed parent, else %FALSE
+ */
+gboolean
+gtk_tree_boxable_get_in_box_info (GtkTreeBoxable *boxable,
+                                  GtkTreeIter    *iter_box,
+                                  gchar         **box,
+                                  gint           *depth,
+                                  GtkTreeIter    *iter)
+{
+  GtkTreeBoxableInterface *iface;
+
+  g_return_val_if_fail (GTK_IS_TREE_BOXABLE (boxable), FALSE);
+  g_return_val_if_fail (iter_box != NULL, FALSE);
+  g_return_val_if_fail (box != NULL, FALSE);
+  g_return_val_if_fail (depth != NULL, FALSE);
+  g_return_val_if_fail (iter != NULL, FALSE);
+
+  iface = GTK_TREE_BOXABLE_GET_IFACE (boxable);
+
+  g_return_val_if_fail (iface != NULL, FALSE);
+  g_return_val_if_fail (iface->get_in_box_info != NULL, FALSE);
+
+  return (*iface->get_in_box_info) (boxable, iter_box, box, depth, iter);
+}
+
+/**
+ * gtk_tree_boxable_get_main_box_info:
+ * @boxable: A #GtkTreeBoxable model
+ * @iter_box: A #GtkTreeIter that will be set to the boxed row
+ * @box: Return location of a pointer for the class name of the box
+ * @depth: Return location for the depth of the boxed row
+ * @iter: #GtkTreeIter of the row to get info for
+ *
+ * Fills in @box and @depth with the box/class name and depth of the boxed row.
+ * This will be @iter if it is boxed itself, else its first boxed parent.
+ * Location of the boxed row will be set in @iter_box.
+ *
+ * To get info on the row itself, or its first boxed parent, see
+ * gtk_tree_boxable_get_current_box_info() and
+ * gtk_tree_boxable_get_in_box_info() respectively.
+ *
+ * Returns: %TRUE if @iter is boxed or has a boxed parent, else %FALSE
+ */
+gboolean
+gtk_tree_boxable_get_main_box_info  (GtkTreeBoxable *boxable,
+                                     GtkTreeIter    *iter_box,
+                                     gchar         **box,
+                                     gint           *depth,
+                                     GtkTreeIter    *iter)
+{
+  GtkTreeBoxableInterface *iface;
+
+  g_return_val_if_fail (GTK_IS_TREE_BOXABLE (boxable), FALSE);
+  g_return_val_if_fail (iter_box != NULL, FALSE);
+  g_return_val_if_fail (box != NULL, FALSE);
+  g_return_val_if_fail (depth != NULL, FALSE);
+  g_return_val_if_fail (iter != NULL, FALSE);
+
+  iface = GTK_TREE_BOXABLE_GET_IFACE (boxable);
+
+  g_return_val_if_fail (iface != NULL, FALSE);
+  g_return_val_if_fail (iface->get_main_box_info != NULL, FALSE);
+
+  return (*iface->get_main_box_info) (boxable, iter_box, box, depth, iter);
+}
diff --git a/gtk/gtktreeboxable.h b/gtk/gtktreeboxable.h
new file mode 100644
index 0000000..c893c60
--- /dev/null
+++ b/gtk/gtktreeboxable.h
@@ -0,0 +1,103 @@
+/* gtktreeboxable.h
+ * Copyright (C) 2013 Olivier Brunel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#if !defined (__GTK_H_INSIDE__) && !defined (GTK_COMPILATION)
+#error "Only <gtk/gtk.h> can be included directly."
+#endif
+
+#ifndef __GTK_TREE_BOXABLE_H__
+#define __GTK_TREE_BOXABLE_H__
+
+
+#include <gtk/gtkenums.h>
+#include <gtk/gtktreemodel.h>
+
+
+G_BEGIN_DECLS
+
+#define GTK_TYPE_TREE_BOXABLE           (gtk_tree_boxable_get_type ())
+#define GTK_TREE_BOXABLE(obj)           (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_TREE_BOXABLE, GtkTreeBoxable))
+#define GTK_TREE_BOXABLE_CLASS(obj)     (G_TYPE_CHECK_CLASS_CAST ((obj), GTK_TYPE_TREE_BOXABLE, GtkTreeBoxableIface))
+#define GTK_IS_TREE_BOXABLE(obj)        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_TREE_BOXABLE))
+#define GTK_TREE_BOXABLE_GET_IFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GTK_TYPE_TREE_BOXABLE, GtkTreeBoxableInterface))
+
+typedef struct _GtkTreeBoxable          GtkTreeBoxable; /* dummy typedef */
+typedef struct _GtkTreeBoxableInterface GtkTreeBoxableInterface;
+
+#define GTK_TREE_BOXABLE_NO_BOX_COLUMN  -1
+
+struct _GtkTreeBoxableInterface
+{
+    GTypeInterface iface;
+
+    /* signal */
+    void            (*box_column_changed)   (GtkTreeBoxable *boxable);
+    /* virtual table */
+    gint            (*get_box_column)       (GtkTreeBoxable *boxable);
+    gboolean        (*set_box_column)       (GtkTreeBoxable *boxable,
+                                             gint            column);
+    gboolean        (*get_current_box_info) (GtkTreeBoxable *boxable,
+                                             gchar         **box,
+                                             gint           *depth,
+                                             GtkTreeIter    *iter);
+    gboolean        (*get_in_box_info)      (GtkTreeBoxable *boxable,
+                                             GtkTreeIter    *iter_box,
+                                             gchar         **box,
+                                             gint           *depth,
+                                             GtkTreeIter    *iter);
+    gboolean        (*get_main_box_info)    (GtkTreeBoxable *boxable,
+                                             GtkTreeIter    *iter_box,
+                                             gchar         **box,
+                                             gint           *depth,
+                                             GtkTreeIter    *iter);
+};
+
+GDK_AVAILABLE_IN_3_10
+GType           gtk_tree_boxable_get_type           (void) G_GNUC_CONST;
+
+/* signals */
+GDK_AVAILABLE_IN_3_10
+void            gtk_tree_boxable_box_column_changed (GtkTreeBoxable *boxable);
+
+/* API */
+GDK_AVAILABLE_IN_3_10
+gint            gtk_tree_boxable_get_box_column     (GtkTreeBoxable *boxable);
+GDK_AVAILABLE_IN_3_10
+gboolean        gtk_tree_boxable_set_box_column     (GtkTreeBoxable *boxable,
+                                                     gint            column);
+GDK_AVAILABLE_IN_3_10
+gboolean        gtk_tree_boxable_get_current_box_info (
+                                                     GtkTreeBoxable *boxable,
+                                                     gchar         **box,
+                                                     gint           *depth,
+                                                     GtkTreeIter    *iter);
+GDK_AVAILABLE_IN_3_10
+gboolean        gtk_tree_boxable_get_in_box_info    (GtkTreeBoxable *boxable,
+                                                     GtkTreeIter    *iter_box,
+                                                     gchar         **box,
+                                                     gint           *depth,
+                                                     GtkTreeIter    *iter);
+GDK_AVAILABLE_IN_3_10
+gboolean        gtk_tree_boxable_get_main_box_info  (GtkTreeBoxable *boxable,
+                                                     GtkTreeIter    *iter_box,
+                                                     gchar         **box,
+                                                     gint           *depth,
+                                                     GtkTreeIter    *iter);
+
+G_END_DECLS
+
+#endif /* __GTK_TREE_BOXABLE_H__ */
diff --git a/gtk/gtktreestore.c b/gtk/gtktreestore.c
index 1ef7a39..82e6ddf 100644
--- a/gtk/gtktreestore.c
+++ b/gtk/gtktreestore.c
@@ -69,6 +69,8 @@ struct _GtkTreeStorePrivate
   gint n_columns;
   gint sort_column_id;
   GList *sort_list;
+  gint box_column;
+  GHashTable *box_htable;
   GType *column_headers;
   GtkTreeIterCompareFunc default_sort_func;
   gpointer default_sort_data;
@@ -85,6 +87,7 @@ static void         gtk_tree_store_tree_model_init (GtkTreeModelIface *iface);
 static void         gtk_tree_store_drag_source_init(GtkTreeDragSourceIface *iface);
 static void         gtk_tree_store_drag_dest_init  (GtkTreeDragDestIface   *iface);
 static void         gtk_tree_store_sortable_init   (GtkTreeSortableIface   *iface);
+static void         gtk_tree_store_boxable_init    (GtkTreeBoxableInterface*iface);
 static void         gtk_tree_store_buildable_init  (GtkBuildableIface      *iface);
 static void         gtk_tree_store_finalize        (GObject           *object);
 static GtkTreeModelFlags gtk_tree_store_get_flags  (GtkTreeModel      *tree_model);
@@ -168,6 +171,29 @@ static void     gtk_tree_store_set_default_sort_func   (GtkTreeSortable        *
 							GDestroyNotify          destroy);
 static gboolean gtk_tree_store_has_default_sort_func   (GtkTreeSortable        *sortable);
 
+/* Boxable Interface */
+static gint     gtk_tree_store_get_box_column          (GtkTreeBoxable         *boxable);
+static gboolean gtk_tree_store_set_box_column          (GtkTreeBoxable         *boxable,
+                                                        gint                    column);
+static gboolean gtk_tree_store_get_current_box_info    (GtkTreeBoxable         *boxable,
+                                                        gchar                 **box,
+                                                        gint                   *depth,
+                                                        GtkTreeIter            *iter);
+static gboolean gtk_tree_store_get_in_box_info         (GtkTreeBoxable         *boxable,
+                                                        GtkTreeIter            *iter_box,
+                                                        gchar                 **box,
+                                                        gint                   *depth,
+                                                        GtkTreeIter            *iter);
+static gboolean gtk_tree_store_get_main_box_info       (GtkTreeBoxable         *boxable,
+                                                        GtkTreeIter            *iter_box,
+                                                        gchar                 **box,
+                                                        gint                   *depth,
+                                                        GtkTreeIter            *iter);
+
+static void _box_process_new (GtkTreeModel *tree_model, GNode *node);
+static void _box_process_change (GtkTreeModel *tree_model, GtkTreeIter *iter);
+static void _box_set_children (GtkTreeModel *tree_model, GtkTreeIter  *parent,
+        GtkTreeIter *box, gboolean init);
 
 /* buildable */
 
@@ -212,6 +238,8 @@ G_DEFINE_TYPE_WITH_CODE (GtkTreeStore, gtk_tree_store, G_TYPE_OBJECT,
 						gtk_tree_store_drag_dest_init)
 			 G_IMPLEMENT_INTERFACE (GTK_TYPE_TREE_SORTABLE,
 						gtk_tree_store_sortable_init)
+			 G_IMPLEMENT_INTERFACE (GTK_TYPE_TREE_BOXABLE,
+			            gtk_tree_store_boxable_init)
 			 G_IMPLEMENT_INTERFACE (GTK_TYPE_BUILDABLE,
 						gtk_tree_store_buildable_init))
 
@@ -268,6 +296,16 @@ gtk_tree_store_sortable_init (GtkTreeSortableIface *iface)
   iface->has_default_sort_func = gtk_tree_store_has_default_sort_func;
 }
 
+static void
+gtk_tree_store_boxable_init (GtkTreeBoxableInterface *iface)
+{
+    iface->get_box_column       = gtk_tree_store_get_box_column;
+    iface->set_box_column       = gtk_tree_store_set_box_column;
+    iface->get_current_box_info = gtk_tree_store_get_current_box_info;
+    iface->get_in_box_info      = gtk_tree_store_get_in_box_info;
+    iface->get_main_box_info    = gtk_tree_store_get_main_box_info;
+}
+
 void
 gtk_tree_store_buildable_init (GtkBuildableIface *iface)
 {
@@ -292,6 +330,7 @@ gtk_tree_store_init (GtkTreeStore *tree_store)
 
   priv->sort_list = NULL;
   priv->sort_column_id = GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID;
+  priv->box_column = GTK_TREE_BOXABLE_NO_BOX_COLUMN;
   priv->columns_dirty = FALSE;
 }
 
@@ -458,11 +497,20 @@ gtk_tree_store_set_column_type (GtkTreeStore *tree_store,
   priv->column_headers[column] = type;
 }
 
+struct node_free
+{
+    GHashTable *box_htable;
+    GType *type;
+};
+
 static gboolean
 node_free (GNode *node, gpointer data)
 {
+  struct node_free *nf = data;
+  if (nf->box_htable)
+      g_hash_table_remove (nf->box_htable, node);
   if (node->data)
-    _gtk_tree_data_list_free (node->data, (GType*)data);
+    _gtk_tree_data_list_free (node->data, nf->type);
   node->data = NULL;
 
   return FALSE;
@@ -473,12 +521,15 @@ gtk_tree_store_finalize (GObject *object)
 {
   GtkTreeStore *tree_store = GTK_TREE_STORE (object);
   GtkTreeStorePrivate *priv = tree_store->priv;
+  struct node_free nf = { NULL, priv->column_headers };
 
   g_node_traverse (priv->root, G_POST_ORDER, G_TRAVERSE_ALL, -1,
-		   node_free, priv->column_headers);
+		   node_free, &nf);
   g_node_destroy (priv->root);
   _gtk_tree_data_list_header_free (priv->sort_list);
   g_free (priv->column_headers);
+  if (priv->box_htable)
+    g_hash_table_unref (priv->box_htable);
 
   if (priv->default_sort_destroy)
     {
@@ -954,6 +1005,8 @@ gtk_tree_store_set_value (GtkTreeStore *tree_store,
     {
       GtkTreePath *path;
 
+      _box_process_change (GTK_TREE_MODEL (tree_store), iter);
+
       path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
       gtk_tree_model_row_changed (GTK_TREE_MODEL (tree_store), path, iter);
       gtk_tree_path_free (path);
@@ -1113,6 +1166,8 @@ gtk_tree_store_set_valuesv (GtkTreeStore *tree_store,
     {
       GtkTreePath *path;
 
+      _box_process_change (GTK_TREE_MODEL (tree_store), iter);
+
       path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
       gtk_tree_model_row_changed (GTK_TREE_MODEL (tree_store), path, iter);
       gtk_tree_path_free (path);
@@ -1153,6 +1208,8 @@ gtk_tree_store_set_valist (GtkTreeStore *tree_store,
     {
       GtkTreePath *path;
 
+      _box_process_change (GTK_TREE_MODEL (tree_store), iter);
+
       path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
       gtk_tree_model_row_changed (GTK_TREE_MODEL (tree_store), path, iter);
       gtk_tree_path_free (path);
@@ -1217,8 +1274,11 @@ gtk_tree_store_remove (GtkTreeStore *tree_store,
   next_node = G_NODE (iter->user_data)->next;
 
   if (G_NODE (iter->user_data)->data)
-    g_node_traverse (G_NODE (iter->user_data), G_POST_ORDER, G_TRAVERSE_ALL,
-		     -1, node_free, priv->column_headers);
+    {
+      struct node_free nf = { priv->box_htable, priv->column_headers };
+      g_node_traverse (G_NODE (iter->user_data), G_POST_ORDER, G_TRAVERSE_ALL,
+		       -1, node_free, &nf);
+    }
 
   path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
   g_node_destroy (G_NODE (iter->user_data));
@@ -1300,6 +1360,8 @@ gtk_tree_store_insert (GtkTreeStore *tree_store,
   iter->user_data = new_node;
   g_node_insert (parent_node, position, new_node);
 
+  _box_process_new (GTK_TREE_MODEL (tree_store), new_node);
+
   path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
   gtk_tree_model_row_inserted (GTK_TREE_MODEL (tree_store), path, iter);
 
@@ -1376,6 +1438,8 @@ gtk_tree_store_insert_before (GtkTreeStore *tree_store,
   iter->stamp = priv->stamp;
   iter->user_data = new_node;
 
+  _box_process_new (GTK_TREE_MODEL (tree_store), new_node);
+
   path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
   gtk_tree_model_row_inserted (GTK_TREE_MODEL (tree_store), path, iter);
 
@@ -1458,6 +1522,8 @@ gtk_tree_store_insert_after (GtkTreeStore *tree_store,
   iter->stamp = priv->stamp;
   iter->user_data = new_node;
 
+  _box_process_new (GTK_TREE_MODEL (tree_store), new_node);
+
   path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
   gtk_tree_model_row_inserted (GTK_TREE_MODEL (tree_store), path, iter);
 
@@ -1546,6 +1612,8 @@ gtk_tree_store_insert_with_values (GtkTreeStore *tree_store,
   iter->user_data = new_node;
   g_node_insert (parent_node, position, new_node);
 
+  _box_process_new (GTK_TREE_MODEL (tree_store), new_node);
+
   va_start (var_args, position);
   gtk_tree_store_set_valist_internal (tree_store, iter,
 				      &changed, &maybe_need_sort,
@@ -1626,6 +1694,8 @@ gtk_tree_store_insert_with_valuesv (GtkTreeStore *tree_store,
   iter->user_data = new_node;
   g_node_insert (parent_node, position, new_node);
 
+  _box_process_new (GTK_TREE_MODEL (tree_store), new_node);
+
   gtk_tree_store_set_vector_internal (tree_store, iter,
 				      &changed, &maybe_need_sort,
 				      columns, values, n_values);
@@ -1691,6 +1761,8 @@ gtk_tree_store_prepend (GtkTreeStore *tree_store,
 
       g_node_prepend (parent_node, G_NODE (iter->user_data));
 
+      _box_process_new (GTK_TREE_MODEL (tree_store), G_NODE (iter->user_data));
+
       path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
       gtk_tree_model_row_inserted (GTK_TREE_MODEL (tree_store), path, iter);
 
@@ -1750,6 +1822,8 @@ gtk_tree_store_append (GtkTreeStore *tree_store,
 
       g_node_append (parent_node, G_NODE (iter->user_data));
 
+      _box_process_new (GTK_TREE_MODEL (tree_store), G_NODE (iter->user_data));
+
       path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), iter);
       gtk_tree_model_row_inserted (GTK_TREE_MODEL (tree_store), path, iter);
 
@@ -2016,6 +2090,8 @@ copy_node_data (GtkTreeStore *tree_store,
 
   G_NODE (dest_iter->user_data)->data = copy_head;
 
+  _box_process_change (GTK_TREE_MODEL (tree_store), dest_iter);
+
   path = gtk_tree_store_get_path (GTK_TREE_MODEL (tree_store), dest_iter);
   gtk_tree_model_row_changed (GTK_TREE_MODEL (tree_store), path, dest_iter);
   gtk_tree_path_free (path);
@@ -3303,6 +3379,253 @@ gtk_tree_store_has_default_sort_func (GtkTreeSortable *sortable)
   return (tree_store->priv->default_sort_func != NULL);
 }
 
+static gint
+gtk_tree_store_get_box_column (GtkTreeBoxable    *boxable)
+{
+  return ((GtkTreeStore *) boxable)->priv->box_column;
+}
+
+static void
+_box_process_new (GtkTreeModel *tree_model, GNode *node)
+{
+  GtkTreeStorePrivate *priv = ((GtkTreeStore *) tree_model)->priv;
+  GNode *box;
+  GtkTreeIter i;
+
+  if (priv->box_column == GTK_TREE_BOXABLE_NO_BOX_COLUMN)
+    return;
+
+  /* look for the first boxed parent (if any) to add in hashtable */
+  i.stamp = priv->stamp;
+  for (box = node->parent; box != priv->root; box = box->parent)
+    {
+      GValue value = G_VALUE_INIT;
+
+      i.user_data = box;
+      gtk_tree_store_get_value (tree_model, &i, priv->box_column, &value);
+      /* we just check if there's something or not */
+      if (g_value_get_string (&value))
+        {
+          g_hash_table_insert (priv->box_htable, node, box);
+          g_value_unset (&value);
+          break;
+        }
+      g_value_unset (&value);
+    }
+}
+
+static inline void
+_box_process_change (GtkTreeModel *tree_model, GtkTreeIter *iter)
+{
+  GtkTreeIter box;
+
+  gtk_tree_store_get_in_box_info (GTK_TREE_BOXABLE (tree_model),
+                                  &box, NULL, NULL, iter);
+  _box_set_children (tree_model, iter, (box.stamp == 0) ? NULL : &box, FALSE);
+}
+
+static void
+_box_set_children (GtkTreeModel *tree_model,
+                   GtkTreeIter  *_parent,
+                   GtkTreeIter  *box,
+                   gboolean      init)
+{
+  GtkTreeStorePrivate *priv = ((GtkTreeStore *) tree_model)->priv;
+  GtkTreeIter parent = *_parent; /* to not modify _parent */
+
+  if (priv->box_column == GTK_TREE_BOXABLE_NO_BOX_COLUMN)
+    return;
+
+  do
+    {
+      GtkTreeIter iter;
+      GValue value = G_VALUE_INIT;
+      const gchar *s;
+
+      if (box)
+        g_hash_table_insert (priv->box_htable, parent.user_data, box->user_data);
+      else if (!init)
+        g_hash_table_remove (priv->box_htable, parent.user_data);
+
+      gtk_tree_store_get_value (tree_model, &parent, priv->box_column, &value);
+      s = g_value_get_string (&value);
+      if (gtk_tree_store_iter_children (tree_model, &iter, &parent))
+        _box_set_children (tree_model, &iter, (s) ? &parent : box, init);
+      g_value_unset (&value);
+    } while (gtk_tree_store_iter_next (tree_model, &parent));
+}
+
+static gboolean
+gtk_tree_store_set_box_column (GtkTreeBoxable *boxable,
+                               gint            column)
+{
+  GtkTreeStorePrivate *priv = ((GtkTreeStore *) boxable)->priv;
+  GtkTreeModel *tree_model = (GtkTreeModel *) boxable;
+  GtkTreeIter iter;
+
+  if (priv->box_column == column)
+    return TRUE;
+
+  if (column == GTK_TREE_BOXABLE_NO_BOX_COLUMN)
+    {
+      if (priv->box_htable)
+        {
+          g_hash_table_unref (priv->box_htable);
+          priv->box_htable = NULL;
+        }
+      priv->box_column = column;
+      gtk_tree_boxable_box_column_changed (boxable);
+      return TRUE;
+    }
+
+  g_return_val_if_fail (column < priv->n_columns, FALSE);
+
+  /* column must contain box/class names */
+  if (priv->column_headers[column] != G_TYPE_STRING)
+    {
+      g_warning ("%s: Column %d cannot be box_column, type %s, must be G_TYPE_STRING\n",
+                 G_STRLOC, column, g_type_name (priv->column_headers[column]));
+      return FALSE;
+    }
+
+  priv->box_column = column;
+
+  /* reset/init our hashmap */
+  if (priv->box_htable)
+    g_hash_table_unref (priv->box_htable);
+  priv->box_htable = g_hash_table_new (g_direct_hash, g_direct_equal);
+
+  /* fill it: get started on the first node (if any) */
+  if (gtk_tree_store_iter_children (tree_model, &iter, NULL))
+    _box_set_children (tree_model, &iter, NULL, TRUE);
+
+  gtk_tree_boxable_box_column_changed (boxable);
+  return TRUE;
+}
+
+static gboolean
+gtk_tree_store_get_current_box_info (GtkTreeBoxable *boxable,
+                                     gchar         **box,
+                                     gint           *depth,
+                                     GtkTreeIter    *iter)
+{
+  GtkTreeStore *tree_store = (GtkTreeStore *) boxable;
+  GtkTreeStorePrivate *priv = tree_store->priv;
+  GValue value = G_VALUE_INIT;
+
+  g_return_val_if_fail (VALID_ITER (iter, tree_store), FALSE);
+
+  if (priv->box_column == GTK_TREE_BOXABLE_NO_BOX_COLUMN)
+    return FALSE;
+
+  /* current box simply comes from the model */
+  gtk_tree_store_get_value ((GtkTreeModel *) tree_store, iter, priv->box_column, &value);
+  *box = g_value_dup_string (&value);
+  g_value_unset (&value);
+
+  if (!*box)
+    {
+      *depth = -1;
+      return FALSE;
+    }
+
+  *depth = g_node_depth (G_NODE (iter->user_data)) - 1;
+  return TRUE;
+}
+
+static gboolean
+gtk_tree_store_get_in_box_info (GtkTreeBoxable *boxable,
+                                GtkTreeIter    *iter_box,
+                                gchar         **box,
+                                gint           *depth,
+                                GtkTreeIter    *iter)
+{
+  GtkTreeStore *tree_store = (GtkTreeStore *) boxable;
+  GtkTreeStorePrivate *priv = tree_store->priv;
+
+  g_return_val_if_fail (VALID_ITER (iter, tree_store), FALSE);
+
+  if (priv->box_column == GTK_TREE_BOXABLE_NO_BOX_COLUMN)
+    return FALSE;
+
+  /* first boxed parent comes from hashtable */
+  iter_box->user_data = g_hash_table_lookup (priv->box_htable, iter->user_data);
+  if (iter_box->user_data)
+    {
+      GValue value = G_VALUE_INIT;
+
+      iter_box->stamp = priv->stamp;
+
+      if (box)
+        {
+          gtk_tree_store_get_value ((GtkTreeModel *) tree_store,
+                                    iter_box, priv->box_column, &value);
+          *box = g_value_dup_string (&value);
+          g_value_unset (&value);
+        }
+
+      if (depth)
+        *depth = g_node_depth (G_NODE (iter_box->user_data)) - 1;
+      return TRUE;
+    }
+  else
+    {
+      iter_box->stamp = 0;
+      if (box)
+        *box = NULL;
+      if (depth)
+        *depth = -1;
+      return FALSE;
+    }
+}
+
+static gboolean
+gtk_tree_store_get_main_box_info (GtkTreeBoxable *boxable,
+                                  GtkTreeIter    *iter_box,
+                                  gchar         **box,
+                                  gint           *depth,
+                                  GtkTreeIter    *iter)
+{
+  GtkTreeStore *tree_store = (GtkTreeStore *) boxable;
+  GtkTreeModel *tree_model = (GtkTreeModel *) tree_store;
+  GtkTreeStorePrivate *priv = tree_store->priv;
+  GValue value = G_VALUE_INIT;
+
+  g_return_val_if_fail (VALID_ITER (iter, tree_store), FALSE);
+
+  if (priv->box_column == GTK_TREE_BOXABLE_NO_BOX_COLUMN)
+    return FALSE;
+
+  /* are we boxed ourself? */
+  gtk_tree_store_get_value (tree_model, iter, priv->box_column, &value);
+  *box = g_value_dup_string (&value);
+  g_value_unset (&value);
+  if (*box)
+    {
+      *iter_box = *iter;
+      *depth = g_node_depth (G_NODE (iter->user_data)) - 1;
+      return TRUE;
+    }
+
+  /* then maybe we have a boxed parent? */
+  iter_box->user_data = g_hash_table_lookup (priv->box_htable, iter->user_data);
+  if (iter_box->user_data)
+    {
+      iter_box->stamp = priv->stamp;
+      gtk_tree_store_get_value (tree_model, iter_box, priv->box_column, &value);
+      *box = g_value_dup_string (&value);
+      g_value_unset (&value);
+      *depth = g_node_depth (G_NODE (iter_box->user_data)) - 1;
+      return TRUE;
+    }
+  else
+    {
+      iter_box->stamp = 0;
+      *depth = -1;
+      return FALSE;
+    }
+}
+
 static void
 validate_gnode (GNode* node)
 {
diff --git a/gtk/gtktreestore.h b/gtk/gtktreestore.h
index 584376d..5493c35 100644
--- a/gtk/gtktreestore.h
+++ b/gtk/gtktreestore.h
@@ -25,6 +25,7 @@
 #include <gdk/gdk.h>
 #include <gtk/gtktreemodel.h>
 #include <gtk/gtktreesortable.h>
+#include <gtk/gtktreeboxable.h>
 #include <stdarg.h>
 
 
diff --git a/gtk/gtktreeview.c b/gtk/gtktreeview.c
index 847f3ea..85181b5 100644
--- a/gtk/gtktreeview.c
+++ b/gtk/gtktreeview.c
@@ -56,6 +56,7 @@
 #include "gtkwidgetpath.h"
 #include "gtkpixelcacheprivate.h"
 #include "a11y/gtktreeviewaccessibleprivate.h"
+#include "gtktreeboxable.h"
 
 
 /**
@@ -701,6 +702,9 @@ static void gtk_tree_view_rows_reordered                  (GtkTreeModel    *mode
 							   GtkTreeIter     *iter,
 							   gint            *new_order,
 							   gpointer         data);
+/* GtkTreeBoxable signals */
+static void gtk_tree_view_box_column_changed              (GtkTreeBoxable  *boxable,
+                                                           gpointer         data);
 
 /* Incremental reflow */
 static gboolean validate_row             (GtkTreeView *tree_view,
@@ -4895,6 +4899,7 @@ gtk_tree_view_bin_draw (GtkWidget      *widget,
   gboolean draw_vgrid_lines, draw_hgrid_lines;
   GtkStyleContext *context;
   gboolean parity;
+  GtkTreeBoxable *boxable;
 
   rtl = (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL);
   context = gtk_widget_get_style_context (widget);
@@ -4961,7 +4966,10 @@ gtk_tree_view_bin_draw (GtkWidget      *widget,
   draw_hgrid_lines =
     tree_view->priv->grid_lines == GTK_TREE_VIEW_GRID_LINES_HORIZONTAL
     || tree_view->priv->grid_lines == GTK_TREE_VIEW_GRID_LINES_BOTH;
-  expander_size = gtk_tree_view_get_expander_size (tree_view);
+  if (gtk_tree_view_draw_expanders (tree_view))
+      expander_size = gtk_tree_view_get_expander_size (tree_view);
+  else
+      expander_size = tree_view->priv->level_indentation;
 
   if (draw_vgrid_lines || draw_hgrid_lines)
     gtk_widget_style_get (widget, "grid-line-width", &grid_line_width, NULL);
@@ -4995,12 +5003,19 @@ gtk_tree_view_bin_draw (GtkWidget      *widget,
   
   parity = !(_gtk_rbtree_node_get_index (tree, node) % 2);
 
+  if (GTK_IS_TREE_BOXABLE (tree_view->priv->model)
+      && gtk_tree_boxable_get_box_column ((GtkTreeBoxable *) tree_view->priv->model) != -1)
+    boxable = (GtkTreeBoxable *) tree_view->priv->model;
+  else
+    boxable = NULL;
+
   do
     {
       gboolean is_separator = FALSE;
       gboolean is_first = FALSE;
       gboolean is_last = FALSE;
       gint n_col = 0;
+      gboolean past_expander = FALSE;
 
       parity = !parity;
       is_separator = row_is_separator (tree_view, &iter, NULL);
@@ -5053,10 +5068,23 @@ gtk_tree_view_bin_draw (GtkWidget      *widget,
           gboolean draw_focus;
           gboolean draw_select_highlight;
           gchar *row_class;
+          /* boxable */
+          GtkTreeIter box_iter;
+          gchar *box;
+          gint box_depth;
+          gboolean bg_drawn = FALSE;
 
 	  if (!gtk_tree_view_column_get_visible (column))
             continue;
 
+          /* we do this here so if the column isn't draw (due to offset) we
+           * still know whether we're past the expander column or not.
+           * Especially important in RTL to not add region & class if the only
+           * column "visible" (as in on screen) is past the expander one */
+          if (boxable && !past_expander &&
+              gtk_tree_view_is_expander_column (tree_view, column))
+            past_expander = TRUE;
+
           n_col++;
           width = gtk_tree_view_column_get_width (column);
 
@@ -5197,12 +5225,112 @@ gtk_tree_view_bin_draw (GtkWidget      *widget,
           draw_select_highlight = tree_view->priv->select_highlight_column == column
               && GTK_RBNODE_FLAG_SET (node, GTK_RBNODE_IS_SELECTED);
 
-	  /* Draw background */
-          gtk_render_background (context, cr,
-                                 background_area.x,
-                                 background_area.y,
-                                 background_area.width,
-                                 background_area.height);
+          if (boxable)
+            {
+              if (gtk_tree_view_is_expander_column (tree_view, column))
+                {
+                  if (gtk_tree_boxable_get_main_box_info (boxable,
+                                                          &box_iter,
+                                                          &box,
+                                                          &box_depth,
+                                                          &iter))
+                    {
+                      gchar *b = box;
+                      gint main_depth = box_depth;
+                      gint prev_depth = box_depth;
+                      GdkRectangle rect = background_area;
+
+                      /* draw the expander part of the "main" box */
+                      gtk_style_context_save (context);
+                      gtk_style_context_add_region (context,
+                                                    GTK_STYLE_REGION_BOXED,
+                                                    row_flags);
+                      if (rtl)
+                        rect.x += rect.width - expander_size * box_depth;
+                      else if (box_depth > 1)
+                        rect.x += expander_size * (box_depth - 1);
+                      rect.width = expander_size;
+                      gtk_style_context_save (context);
+                      gtk_style_context_add_class (context, box);
+                      gtk_render_background (context, cr,
+                                             rect.x, rect.y,
+                                             rect.width, rect.height);
+                      gtk_style_context_restore (context);
+
+                      /* draw the expander part of parent boxes */
+                      while (gtk_tree_boxable_get_in_box_info (boxable,
+                             &box_iter,
+                             &box,
+                             &box_depth,
+                             &box_iter))
+                        {
+                          rect = background_area;
+                          if (rtl)
+                            rect.x += rect.width - box_depth * expander_size;
+                          else
+                            rect.x += (box_depth - 1) * expander_size;
+                          rect.width = expander_size * (prev_depth - box_depth);
+                          gtk_style_context_save (context);
+                          gtk_style_context_add_class (context, box);
+                          gtk_render_background (context, cr,
+                                                 rect.x, rect.y,
+                                                 rect.width, rect.height);
+                          gtk_style_context_restore (context);
+                          prev_depth = box_depth;
+                          g_free (box);
+                        }
+
+                      /* remove the region */
+                      gtk_style_context_restore (context);
+
+                      /* draw the non-boxed part before */
+                      if (prev_depth > 1)
+                        {
+                          rect = background_area;
+                          if (rtl)
+                              rect.x += rect.width - expander_size * (prev_depth - 1);
+                          rect.width = expander_size * (prev_depth - 1);
+                          gtk_render_background (context, cr,
+                                                 rect.x, rect.y,
+                                                 rect.width, rect.height);
+                        }
+
+                      /* draw the rest of the (boxed) cell */
+                      gtk_style_context_add_class (context, b);
+                      rect = background_area;
+                      rect.width -= expander_size * main_depth;
+                      if (!rtl)
+                        rect.x += expander_size * main_depth;
+                      gtk_render_background (context, cr,
+                                             rect.x, rect.y,
+                                             rect.width, rect.height);
+                      g_free (b);
+                      bg_drawn = TRUE;
+                    }
+                }
+              else
+                {
+                  /* past the expander column, we just add the class */
+                  if (((!rtl && past_expander) || (rtl && !past_expander))
+                          && gtk_tree_boxable_get_main_box_info (boxable,
+                                                                 &box_iter,
+                                                                 &box,
+                                                                 &box_depth,
+                                                                 &iter))
+                    {
+                      gtk_style_context_add_class (context, box);
+                      g_free (box);
+                    }
+                }
+            }
+
+          if (!bg_drawn)
+              /* Draw background */
+              gtk_render_background (context, cr,
+                                     background_area.x,
+                                     background_area.y,
+                                     background_area.width,
+                                     background_area.height);
 
           /* Draw frame */
           gtk_render_frame (context, cr,
@@ -5219,7 +5347,6 @@ gtk_tree_view_bin_draw (GtkWidget      *widget,
 
               if (gtk_tree_view_draw_expanders (tree_view))
 	        {
-                  int expander_size = gtk_tree_view_get_expander_size (tree_view);
 	          if (!rtl)
 		    cell_area.x += depth * expander_size;
 		  cell_area.width -= depth * expander_size;
@@ -9379,6 +9506,13 @@ gtk_tree_view_rows_reordered (GtkTreeModel *model,
   gtk_tree_view_dy_to_top_row (tree_view);
 }
 
+/* GtkTreeBoxable callbacks */
+
+static void
+gtk_tree_view_box_column_changed (GtkTreeBoxable *boxable, gpointer data)
+{
+  gtk_widget_queue_draw ((GtkWidget *) data);
+}
 
 /* Internal tree functions
  */
@@ -11454,6 +11588,10 @@ gtk_tree_view_set_model (GtkTreeView  *tree_view,
       g_signal_handlers_disconnect_by_func (tree_view->priv->model,
 					    gtk_tree_view_rows_reordered,
 					    tree_view);
+      if (GTK_IS_TREE_BOXABLE (tree_view->priv->model))
+        g_signal_handlers_disconnect_by_func (tree_view->priv->model,
+                                              gtk_tree_view_box_column_changed,
+                                              tree_view);
 
       for (; tmplist; tmplist = tmplist->next)
 	_gtk_tree_view_column_unset_model (tmplist->data,
@@ -11528,6 +11666,11 @@ gtk_tree_view_set_model (GtkTreeView  *tree_view,
 			"rows-reordered",
 			G_CALLBACK (gtk_tree_view_rows_reordered),
 			tree_view);
+      if (GTK_IS_TREE_BOXABLE (tree_view->priv->model))
+        g_signal_connect (tree_view->priv->model,
+                          "box-column-changed",
+                          G_CALLBACK (gtk_tree_view_box_column_changed),
+                          tree_view);
 
       flags = gtk_tree_model_get_flags (tree_view->priv->model);
       if ((flags & GTK_TREE_MODEL_LIST_ONLY) == GTK_TREE_MODEL_LIST_ONLY)
-- 
1.9.2

