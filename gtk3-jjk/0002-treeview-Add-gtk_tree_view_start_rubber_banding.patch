From 6d5f8d1887f8e9264107cdd4a11205cd901e5fd6 Mon Sep 17 00:00:00 2001
From: Olivier Brunel <jjk@jjacky.com>
Date: Tue, 15 Oct 2013 16:43:37 +0200
Subject: [PATCH 2/3] treeview: Add gtk_tree_view_start_rubber_banding()

This allows to start a rubber banding operation based on one's own criteria,
e.g. only from blank space, a specific column/button, etc

Also adds a new signal rubber-banding-active, emitted when the operation gets
active/the drag starts, as well as gtk_tree_view_stop_rubber_banding() to stop
an operation.

gtk_tree_view_is_rubber_banding_pending() is also added, allowing to determine
if a rubber banding operation is "pending", i.e. will be started if the mouse
moves w/out releasing the button; It can optionally also return TRUE if an
operation is active as well.

Signed-off-by: Olivier Brunel <jjk@jjacky.com>
---
 docs/reference/gtk/gtk3-sections.txt |   3 +
 gtk/gtktreeview.c                    | 204 ++++++++++++++++++++++++++---------
 gtk/gtktreeview.h                    |   9 ++
 3 files changed, 165 insertions(+), 51 deletions(-)

diff --git a/docs/reference/gtk/gtk3-sections.txt b/docs/reference/gtk/gtk3-sections.txt
index 27bb480..2c1bdd4 100644
--- a/docs/reference/gtk/gtk3-sections.txt
+++ b/docs/reference/gtk/gtk3-sections.txt
@@ -4661,7 +4661,10 @@ gtk_tree_view_get_row_separator_func
 gtk_tree_view_set_row_separator_func
 gtk_tree_view_get_rubber_banding
 gtk_tree_view_set_rubber_banding
+gtk_tree_view_start_rubber_banding
+gtk_tree_view_stop_rubber_banding
 gtk_tree_view_is_rubber_banding_active
+gtk_tree_view_is_rubber_banding_pending
 gtk_tree_view_get_enable_tree_lines
 gtk_tree_view_set_enable_tree_lines
 GtkTreeViewGridLines
diff --git a/gtk/gtktreeview.c b/gtk/gtktreeview.c
index 4389e16..c6a7cc5 100644
--- a/gtk/gtktreeview.c
+++ b/gtk/gtktreeview.c
@@ -535,6 +535,7 @@ enum
   EXPAND_COLLAPSE_CURSOR_ROW,
   SELECT_CURSOR_PARENT,
   START_INTERACTIVE_SEARCH,
+  RUBBER_BANDING_ACTIVE,
   LAST_SIGNAL
 };
 
@@ -793,7 +794,6 @@ static gboolean gtk_tree_view_has_can_focus_cell             (GtkTreeView
 static void     column_sizing_notify                         (GObject            *object,
                                                               GParamSpec         *pspec,
                                                               gpointer            data);
-static void     gtk_tree_view_stop_rubber_band               (GtkTreeView        *tree_view);
 static void     update_prelight                              (GtkTreeView        *tree_view,
                                                               int                 x,
                                                               int                 y);
@@ -1504,6 +1504,15 @@ gtk_tree_view_class_init (GtkTreeViewClass *class)
 		  _gtk_marshal_BOOLEAN__VOID,
 		  G_TYPE_BOOLEAN, 0);
 
+  tree_view_signals[RUBBER_BANDING_ACTIVE] =
+    g_signal_new (I_("rubber-banding-active"),
+		  G_TYPE_FROM_CLASS (o_class),
+		  G_SIGNAL_RUN_FIRST,
+		  G_STRUCT_OFFSET (GtkTreeViewClass, rubber_banding_active),
+		  NULL, NULL,
+		  _gtk_marshal_VOID__VOID,
+		  G_TYPE_NONE, 0);
+
   /* Key bindings */
   gtk_tree_view_add_move_binding (binding_set, GDK_KEY_Up, 0, TRUE,
 				  GTK_MOVEMENT_DISPLAY_LINES, -1);
@@ -3457,7 +3466,7 @@ gtk_tree_view_button_release (GtkWidget      *widget,
     return gtk_tree_view_button_release_drag_column (widget, event);
 
   if (tree_view->priv->rubber_band_status)
-    gtk_tree_view_stop_rubber_band (tree_view);
+    gtk_tree_view_stop_rubber_banding (tree_view, TRUE);
 
   if (tree_view->priv->pressed_button == event->button)
     tree_view->priv->pressed_button = -1;
@@ -4206,52 +4215,6 @@ gtk_tree_view_motion_drag_column (GtkWidget      *widget,
 }
 
 static void
-gtk_tree_view_stop_rubber_band (GtkTreeView *tree_view)
-{
-  remove_scroll_timeout (tree_view);
-  gtk_grab_remove (GTK_WIDGET (tree_view));
-
-  if (tree_view->priv->rubber_band_status == RUBBER_BAND_ACTIVE)
-    {
-      GtkTreePath *tmp_path;
-
-      gtk_widget_queue_draw (GTK_WIDGET (tree_view));
-
-      /* The anchor path should be set to the start path */
-      tmp_path = _gtk_tree_path_new_from_rbtree (tree_view->priv->rubber_band_start_tree,
-					         tree_view->priv->rubber_band_start_node);
-
-      if (tree_view->priv->anchor)
-	gtk_tree_row_reference_free (tree_view->priv->anchor);
-
-      tree_view->priv->anchor =
-	gtk_tree_row_reference_new_proxy (G_OBJECT (tree_view),
-					  tree_view->priv->model,
-					  tmp_path);
-
-      gtk_tree_path_free (tmp_path);
-
-      /* ... and the cursor to the end path */
-      tmp_path = _gtk_tree_path_new_from_rbtree (tree_view->priv->rubber_band_end_tree,
-                                                 tree_view->priv->rubber_band_end_node);
-      gtk_tree_view_real_set_cursor (GTK_TREE_VIEW (tree_view), tmp_path, 0);
-      gtk_tree_path_free (tmp_path);
-
-      _gtk_tree_selection_emit_changed (tree_view->priv->selection);
-    }
-
-  /* Clear status variables */
-  tree_view->priv->rubber_band_status = RUBBER_BAND_OFF;
-  tree_view->priv->rubber_band_extend = FALSE;
-  tree_view->priv->rubber_band_modify = FALSE;
-
-  tree_view->priv->rubber_band_start_node = NULL;
-  tree_view->priv->rubber_band_start_tree = NULL;
-  tree_view->priv->rubber_band_end_node = NULL;
-  tree_view->priv->rubber_band_end_tree = NULL;
-}
-
-static void
 gtk_tree_view_update_rubber_band_selection_range (GtkTreeView *tree_view,
 						 GtkRBTree   *start_tree,
 						 GtkRBNode   *start_node,
@@ -4562,6 +4525,7 @@ gtk_tree_view_motion_bin_window (GtkWidget      *widget,
       gtk_tree_view_update_rubber_band (tree_view);
 
       tree_view->priv->rubber_band_status = RUBBER_BAND_ACTIVE;
+      g_signal_emit (tree_view, tree_view_signals[RUBBER_BANDING_ACTIVE], 0);
     }
   else if (tree_view->priv->rubber_band_status == RUBBER_BAND_ACTIVE)
     {
@@ -5742,7 +5706,7 @@ gtk_tree_view_key_press (GtkWidget   *widget,
   if (tree_view->priv->rubber_band_status)
     {
       if (event->keyval == GDK_KEY_Escape)
-	gtk_tree_view_stop_rubber_band (tree_view);
+	gtk_tree_view_stop_rubber_banding (tree_view, TRUE);
 
       return TRUE;
     }
@@ -11268,7 +11232,7 @@ gtk_tree_view_set_model (GtkTreeView  *tree_view,
     }
 
   if (tree_view->priv->rubber_band_status)
-    gtk_tree_view_stop_rubber_band (tree_view);
+    gtk_tree_view_stop_rubber_banding (tree_view, TRUE);
 
   if (tree_view->priv->model)
     {
@@ -15721,6 +15685,116 @@ gtk_tree_view_get_rubber_banding (GtkTreeView *tree_view)
 }
 
 /**
+ * gtk_tree_view_start_rubber_banding:
+ * @tree_view: a #GtkTreeView
+ * @event: a #GdkEventButton from the ::button-press-event triggering the rubber
+ * banding
+ *
+ * Initiates a new rubber banding operation. This will do nothing and return
+ * %FALSE if one is already in place, or the selection mode isn't
+ * %GTK_SELECTION_MULTIPLE.
+ *
+ * You don't need to set ::rubber-banding for this to work, as the property only
+ * sets whether rubber banding operations are automatically started by GTK or
+ * not. Obviously, you should only call this from ::button-press-event using the
+ * associated #GdkEvenButton for things to work correctly.
+ *
+ * Return: %TRUE if a new rubber banding was initiated in @tree_view
+ *
+ * Since: 3.10
+ */
+gboolean
+gtk_tree_view_start_rubber_banding (GtkTreeView     *tree_view,
+                                    GdkEventButton  *event)
+{
+  GdkModifierType modify_mod_mask;
+  GdkModifierType extend_mod_mask;
+
+  g_return_val_if_fail (GTK_IS_TREE_VIEW (tree_view), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  if (tree_view->priv->rubber_band_status != RUBBER_BAND_OFF
+      || gtk_tree_selection_get_mode (tree_view->priv->selection) != GTK_SELECTION_MULTIPLE)
+    return FALSE;
+
+  extend_mod_mask = gtk_widget_get_modifier_mask ((GtkWidget *) tree_view,
+      GDK_MODIFIER_INTENT_EXTEND_SELECTION);
+  modify_mod_mask = gtk_widget_get_modifier_mask ((GtkWidget *) tree_view,
+      GDK_MODIFIER_INTENT_MODIFY_SELECTION);
+
+  tree_view->priv->press_start_x = event->x;
+  tree_view->priv->press_start_y = event->y + tree_view->priv->dy;
+  tree_view->priv->rubber_band_x = event->x;
+  tree_view->priv->rubber_band_y = event->y + tree_view->priv->dy;
+  tree_view->priv->rubber_band_status = RUBBER_BAND_MAYBE_START;
+  if ((event->state & modify_mod_mask) == modify_mod_mask)
+    tree_view->priv->rubber_band_modify = TRUE;
+  if ((event->state & extend_mod_mask) == extend_mod_mask)
+    tree_view->priv->rubber_band_extend = TRUE;
+
+  return TRUE;
+}
+
+/**
+ * gtk_tree_view_stop_rubber_banding:
+ * @tree_view: A #GtkTreeView
+ * @set_cursor: Whether to set cursor to the last row in band or not
+ *
+ * Stop currently active rubber banding operation.
+ *
+ * Since: 3.10
+ */
+void
+gtk_tree_view_stop_rubber_banding (GtkTreeView *tree_view, gboolean set_cursor)
+{
+  remove_scroll_timeout (tree_view);
+
+  if (tree_view->priv->rubber_band_status == RUBBER_BAND_ACTIVE)
+    {
+      GtkTreePath *tmp_path;
+
+      gtk_grab_remove (GTK_WIDGET (tree_view));
+      gtk_widget_queue_draw (GTK_WIDGET (tree_view));
+
+      /* The anchor path should be set to the start path */
+      tmp_path = _gtk_tree_path_new_from_rbtree (tree_view->priv->rubber_band_start_tree,
+					         tree_view->priv->rubber_band_start_node);
+
+      if (tree_view->priv->anchor)
+	gtk_tree_row_reference_free (tree_view->priv->anchor);
+
+      tree_view->priv->anchor =
+	gtk_tree_row_reference_new_proxy (G_OBJECT (tree_view),
+					  tree_view->priv->model,
+					  tmp_path);
+
+      gtk_tree_path_free (tmp_path);
+
+      /* ... and the cursor to the end path */
+      if (set_cursor)
+        {
+          tmp_path = _gtk_tree_path_new_from_rbtree (tree_view->priv->rubber_band_end_tree,
+                                                     tree_view->priv->rubber_band_end_node);
+          gtk_tree_view_real_set_cursor (GTK_TREE_VIEW (tree_view), tmp_path, 0);
+          gtk_tree_path_free (tmp_path);
+        }
+
+      _gtk_tree_selection_emit_changed (tree_view->priv->selection);
+    }
+
+  /* Clear status variables */
+  tree_view->priv->rubber_band_status = RUBBER_BAND_OFF;
+  tree_view->priv->rubber_band_extend = FALSE;
+  tree_view->priv->rubber_band_modify = FALSE;
+
+  tree_view->priv->rubber_band_start_node = NULL;
+  tree_view->priv->rubber_band_start_tree = NULL;
+  tree_view->priv->rubber_band_end_node = NULL;
+  tree_view->priv->rubber_band_end_tree = NULL;
+}
+
+
+/**
  * gtk_tree_view_is_rubber_banding_active:
  * @tree_view: a #GtkTreeView
  * 
@@ -15744,6 +15818,34 @@ gtk_tree_view_is_rubber_banding_active (GtkTreeView *tree_view)
 }
 
 /**
+ * gtk_tree_view_is_rubber_banding_pending:
+ * @tree_view: a #GtkTreeView
+ * @or_active: Whether to return %TRUE is rubber banding is active or not
+ *
+ * Returns whether a rubber banding operation is currently "pending," as in it
+ * will start when/if the mouse moves and the button isn't released.
+ *
+ * If @or_active is %TRUE then it will also return %TRUE is an operation is
+ * already active.
+ *
+ * Return value: %TRUE if a rubber banding operation is currently "pending"
+ * on in @tree_view, or active if @or_active was %TRUE.
+ *
+ * Since: 3.10
+ **/
+gboolean
+gtk_tree_view_is_rubber_banding_pending (GtkTreeView *tree_view, gboolean or_active)
+{
+  g_return_val_if_fail (GTK_IS_TREE_VIEW (tree_view), FALSE);
+
+  if (tree_view->priv->rubber_band_status == RUBBER_BAND_MAYBE_START
+          || (or_active && tree_view->priv->rubber_band_status == RUBBER_BAND_ACTIVE))
+    return TRUE;
+
+  return FALSE;
+}
+
+/**
  * gtk_tree_view_get_row_separator_func: (skip)
  * @tree_view: a #GtkTreeView
  * 
@@ -15808,7 +15910,7 @@ gtk_tree_view_grab_notify (GtkWidget *widget,
       tree_view->priv->pressed_button = -1;
 
       if (tree_view->priv->rubber_band_status)
-	gtk_tree_view_stop_rubber_band (tree_view);
+	gtk_tree_view_stop_rubber_banding (tree_view, TRUE);
     }
 }
 
diff --git a/gtk/gtktreeview.h b/gtk/gtktreeview.h
index 5ccc300..875948a 100644
--- a/gtk/gtktreeview.h
+++ b/gtk/gtktreeview.h
@@ -536,9 +536,18 @@ void     gtk_tree_view_set_rubber_banding    (GtkTreeView          *tree_view,
 					      gboolean              enable);
 GDK_AVAILABLE_IN_ALL
 gboolean gtk_tree_view_get_rubber_banding    (GtkTreeView          *tree_view);
+GDK_AVAILABLE_IN_3_10
+gboolean gtk_tree_view_start_rubber_banding  (GtkTreeView          *tree_view,
+                                              GdkEventButton       *event);
+GDK_AVAILABLE_IN_3_10
+void     gtk_tree_view_stop_rubber_banding   (GtkTreeView          *tree_view,
+                                              gboolean              set_cursor);
 
 GDK_AVAILABLE_IN_ALL
 gboolean gtk_tree_view_is_rubber_banding_active (GtkTreeView       *tree_view);
+GDK_AVAILABLE_IN_3_10
+gboolean gtk_tree_view_is_rubber_banding_pending (GtkTreeView      *tree_view,
+                                                  gboolean           or_active);
 
 GDK_AVAILABLE_IN_ALL
 GtkTreeViewRowSeparatorFunc gtk_tree_view_get_row_separator_func (GtkTreeView               *tree_view);
-- 
1.8.4

