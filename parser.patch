diff -rupN dtach-0.8.orig/Makefile.in dtach-0.8/Makefile.in
--- dtach-0.8.orig/Makefile.in	2010-11-15 12:56:45.529835250 -0500
+++ dtach-0.8/Makefile.in	2010-11-18 17:04:29.010842914 -0500
@@ -9,6 +9,11 @@ VPATH = $(srcdir)
 OBJ = attach.o master.o main.o
 SRC = $(srcdir)/attach.c $(srcdir)/master.c $(srcdir)/main.c
 
+ifeq (@enable_parser@, yes)
+	OBJ += parser.o
+	SRC += parser.c
+endif
+
 TARFILES = $(srcdir)/README $(srcdir)/COPYING $(srcdir)/Makefile.in \
 	   $(srcdir)/config.h.in $(SRC) \
 	   $(srcdir)/dtach.h $(srcdir)/dtach.spec $(srcdir)/configure \
diff -rupN dtach-0.8.orig/configure.ac dtach-0.8/configure.ac
--- dtach-0.8.orig/configure.ac	2010-11-15 12:56:45.529835250 -0500
+++ dtach-0.8/configure.ac	2010-11-18 17:04:29.010842914 -0500
@@ -32,5 +32,15 @@ AC_CHECK_FUNCS(atexit dup2 memset)
 AC_CHECK_FUNCS(select socket strerror)
 AC_CHECK_FUNCS(openpty forkpty ptsname grantpt unlockpt)
 
+# Check to see if parser is being configured in
+AC_ARG_ENABLE(parser,
+	      AS_HELP_STRING([--enable-parser], [Enables a minimal terminal sequence parser]))
+AS_IF([test "x$enable_parser" = "xyes"], [
+       AC_SEARCH_LIBS(tigetstr, ncurses curses, [] ,
+		      [AC_MSG_FAILURE([Could not find curses library])])
+       AC_DEFINE(PARSER, 1, [Define to enable minimal terminal sequence parser.])
+])
+AC_SUBST(enable_parser)
+
 AC_CONFIG_FILES(Makefile)
 AC_OUTPUT
diff -rupN dtach-0.8.orig/dtach.h dtach-0.8/dtach.h
--- dtach-0.8.orig/dtach.h	2010-11-15 12:56:45.529835250 -0500
+++ dtach-0.8/dtach.h	2010-11-18 17:04:29.010842914 -0500
@@ -134,3 +134,37 @@ int master_main(char **argv, int waitatt
 #define BROKEN_MASTER
 #endif
 #endif
+
+/* The pty struct - The pty information is stored here. */
+struct pty
+{
+	/* File descriptor of the pty */
+	int fd;
+#ifdef BROKEN_MASTER
+	/* File descriptor of the slave side of the pty. For broken systems. */
+	int slave;
+#endif
+	/* Process id of the child. */
+	pid_t pid;
+	/* The terminal parameters of the pty. Old and new for comparision
+	** purposes. */
+	struct termios term;
+	/* The current window size of the pty. */
+	struct winsize ws;
+	/* Buffer for I/O. */
+	char buf[BUFSIZE];
+#ifdef PARSER
+	/* Number of characters left in buffer. */
+	int leftover;
+	/* Keypad mode */
+	int smkx;
+	/* Alt-screen mode */
+	int smcup;
+#endif
+};
+
+#ifdef PARSER
+int parser_init(struct pty *p);
+int parse_buf(struct pty *p, unsigned int count, unsigned int *rem);
+int restore_state(struct pty *p, int fd);
+#endif
diff -rupN dtach-0.8.orig/master.c dtach-0.8/master.c
--- dtach-0.8.orig/master.c	2010-11-15 12:56:45.529835250 -0500
+++ dtach-0.8/master.c	2010-11-18 17:07:29.227732312 -0500
@@ -18,24 +18,6 @@
 */
 #include "dtach.h"
 
-/* The pty struct - The pty information is stored here. */
-struct pty
-{
-	/* File descriptor of the pty */
-	int fd;
-#ifdef BROKEN_MASTER
-	/* File descriptor of the slave side of the pty. For broken systems. */
-	int slave;
-#endif
-	/* Process id of the child. */
-	pid_t pid;
-	/* The terminal parameters of the pty. Old and new for comparision
-	** purposes. */
-	struct termios term;
-	/* The current window size of the pty. */
-	struct winsize ws;
-};
-
 /* A connected client */
 struct client
 {
@@ -219,18 +201,30 @@ create_socket(char *name)
 static void
 pty_activity(int s)
 {
-	unsigned char buf[BUFSIZE];
 	int len;
 	struct client *p;
 	fd_set readfds, writefds;
 	int highest_fd, nclients;
 
+#ifdef PARSER
+	int rlen;
+	unsigned int rem;
+
+	/* Read the pty activity */
+	rlen = read(the_pty.fd, the_pty.buf + the_pty.leftover,
+			sizeof(the_pty.buf) - the_pty.leftover);
+
+	/* Error -> die */
+	if (rlen <= 0)
+		exit(1);
+#else
 	/* Read the pty activity */
-	len = read(the_pty.fd, buf, sizeof(buf));
+	len = read(the_pty.fd, the_pty.buf, sizeof(the_pty.buf));
 
 	/* Error -> die */
 	if (len <= 0)
 		exit(1);
+#endif
 
 #ifdef BROKEN_MASTER
 	/* Get the current terminal settings. */
@@ -242,6 +236,10 @@ pty_activity(int s)
 		exit(1);
 #endif
 
+#ifdef PARSER
+	len = parse_buf(&the_pty, rlen, &rem);
+#endif
+
 top:
 	/*
 	** Wait until at least one client is writable. Also wait on the control
@@ -276,7 +274,8 @@ top:
 		written = 0;
 		while (written < len)
 		{
-			int n = write(p->fd, buf + written, len - written);
+			int n = write(p->fd, the_pty.buf + written,
+					len - written);
 
 			if (n > 0)
 			{
@@ -296,6 +295,11 @@ top:
 	/* Try again if nothing happened. */
 	if (!FD_ISSET(s, &readfds) && nclients == 0)
 		goto top;
+#ifdef PARSER
+	/* Move any leftover bytes to the front of the buffer */
+	memmove(the_pty.buf, the_pty.buf + the_pty.leftover + rlen - rem, rem);
+	the_pty.leftover = rem;
+#endif
 }
 
 /* Process activity on the control socket */
@@ -324,6 +328,9 @@ control_activity(int s)
 	if (p->next)
 		p->next->pprev = &p->next;
 	*(p->pprev) = p;
+#ifdef PARSER
+	restore_state(&the_pty, fd);
+#endif
 }
 
 /* Process activity from a client. */
@@ -437,6 +444,16 @@ master_process(int s, char **argv, int w
 		printf("%s: init_pty: %s\n", progname, strerror(errno));
 		exit(1);
 	}
+
+#ifdef PARSER
+	if (parser_init(&the_pty))
+	{
+		if (statusfd != -1)
+			dup2(statusfd, 1);
+		printf("%s: parser_init failed\n", progname);
+		exit(1);
+	}
+#endif
 	
 	/* Close statusfd, since we don't need it anymore. */
 	if (statusfd != -1)
diff -rupN dtach-0.8.orig/parser.c dtach-0.8/parser.c
--- dtach-0.8.orig/parser.c	1969-12-31 19:00:00.000000000 -0500
+++ dtach-0.8/parser.c	2010-11-18 17:06:08.804353980 -0500
@@ -0,0 +1,251 @@
+#include <string.h>
+#include <stdlib.h>
+#include <curses.h>
+#include <term.h>
+
+#include "dtach.h"
+
+enum
+{
+	MATCH_DELETE,
+	MATCH_SMKX,
+	MATCH_RMKX,
+	MATCH_SMCUP,
+	MATCH_RMCUP,
+};
+
+struct needle
+{
+	struct needle *next;
+	char *str;
+	short *table;
+	short j;
+	unsigned short action;
+};
+
+/*
+** Set up common answerback needles. Since none has any KMP fallback matches, we
+** can use the same table for all of them.
+*/
+static short anstables[] = {-1, 0, 0, 0, 0};
+static struct needle ans4 = {
+	.next = NULL,
+	.str = "\033[>0c",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans3 = {
+	.next = &ans4,
+	.str = "\033[>c",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans2 = {
+	.next = &ans3,
+	.str = "\033[c",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans1 = {
+	.next = &ans2,
+	.str = "\033Z",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans0 = {
+	.next = &ans1,
+	.str = "\005",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle smkx, rmkx, smcup, rmcup;
+
+static struct needle *pincushion = &ans0, *pctail = &ans4;
+
+/*
+** Sets up the KMP fallback table for a needle.  Note that the table must be
+** allocated already.
+*/
+static void kmp_setup(struct needle *n)
+{
+	short i, j;
+
+	for (i = 0, j = -2; n->str[i]; i++)
+	{
+		while (j >= 0 && n->str[i - 1] != n->str[j])
+			j = n->table[j];
+		n->table[i] = ++j;
+	}
+}
+
+static int terminfo_needle(char *id, struct needle *n, unsigned short action)
+{
+	n->str = tigetstr(id);
+	if (!n->str)
+		return 0;
+	n->table = malloc(strlen(n->str) * sizeof (int));
+	if (!n->table)
+		return 1;
+	kmp_setup(n);
+	n->action = action;
+	pctail->next = n;
+	pctail = n;
+	return 0;
+}
+
+/*
+** Initializes the parser.
+*/
+int parser_init(struct pty *p)
+{
+	p->leftover = 0;
+	p->smkx = 0;
+	p->smcup = 0;
+	return (setupterm(NULL, p->fd, NULL) == ERR ||
+			terminfo_needle("smkx", &smkx, MATCH_SMKX) ||
+			terminfo_needle("rmkx", &rmkx, MATCH_RMKX) ||
+			terminfo_needle("smcup", &smcup, MATCH_SMCUP) ||
+			terminfo_needle("rmcup", &rmcup, MATCH_RMCUP));
+}
+
+/*
+** When successful, returns first needle found in haystack and places the index
+** right after the needle in next.  Otherwise, returns NULL and places count in
+** next.
+**
+** NOTE: This function is not generic in that it returns immediately when a
+** match is found.  This leaves the pincushion's j-values in an inconsistent
+** state, since the remaining needles for that pass have not been processed.  We
+** clear the j-values on a match, so this doesn't hurt here.
+*/
+static struct needle *kmp_search(const char *haystack, unsigned int count,
+		int *next)
+{
+	unsigned int i;
+	struct needle *n;
+
+	for (i = 0; i < count; i++)
+	{
+		for (n = pincushion; n; n = n->next)
+		{
+			while (n->j >= 0 && haystack[i] != n->str[n->j])
+				n->j = n->table[n->j];
+			if (!n->str[++n->j])
+			{
+				/* Found a match */
+				*next = i + 1;
+				return n;
+			}
+		}
+	}
+	/* Reached end with no match (i == count) */
+	*next = count;
+	return NULL;
+}
+
+/*
+** Process as much of the buffer as possible, rewriting it in place.  Returns
+** the new length of the buffer.  Puts the number of leftover bytes in rem.
+*/
+int parse_buf(struct pty *p, unsigned int count, unsigned int *rem)
+{
+	/* where to put good characters */
+	char *end;
+	/* next character being examined */
+	char *next;
+	struct needle *n;
+	int i, c;
+
+	end = next = p->buf + p->leftover;
+	while ((n = kmp_search(next, count, &i)))
+	{
+		/* c is number of "good" characters to append to buffer */
+		c = i;
+		switch (n->action)
+		{
+			case MATCH_DELETE:
+				c -= n->j;
+				break;
+			case MATCH_SMKX:
+				p->smkx = 1;
+				break;
+			case MATCH_RMKX:
+				p->smkx = 0;
+				break;
+			case MATCH_SMCUP:
+				p->smcup = 1;
+				break;
+			case MATCH_RMCUP:
+				p->smcup = 0;
+				break;
+		}
+		if (c > 0)
+			memmove(end, next, c);
+		end += c;
+		count -= i;
+		next += i;
+		for (n = pincushion; n; n = n->next)
+			n->j = 0;
+	}
+	/* Here c is number of potentially "bad" characters at end of buffer */
+	c = 0;
+	for (n = pincushion; n; n = n->next)
+		if (n->j > c)
+			c = n->j;
+	/* When kmp_search fails, i is set to count */
+	i -= c;
+	if (i > 0)
+		memmove(end, next, i);
+	end += i;
+	*rem = c;
+	return end - p->buf;
+}
+
+/*
+** Restores the state of a pty by replaying control sequences to the given fd.
+*/
+int restore_state(struct pty *p, int fd)
+{
+	int len, written, n;
+
+	if (p->smkx)
+	{
+		len = strlen(smkx.str);
+		n = 0;
+		for (written = 0; written < len; written += n)
+		{
+			n = write(fd, smkx.str + written, len - written);
+			if (n <= 0)
+			{
+				if (n == 0 || errno == EAGAIN)
+					break;
+				if (errno != EINTR)
+					return errno;
+				n = 0;
+			}
+		}
+	}
+	if (p->smcup)
+	{
+		len = strlen(smcup.str);
+		n = 0;
+		for (written = 0; written < len; written += n)
+		{
+			n = write(fd, smcup.str + written, len - written);
+			if (n <= 0)
+			{
+				if (n == 0 || errno == EAGAIN)
+					break;
+				if (errno != EINTR)
+					return errno;
+				n = 0;
+			}
+		}
+	}
+	return 0;
+}
