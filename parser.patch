diff -rNU8 -x configure -x config.h.in dtach-0.8.orig/Makefile.in dtach-0.8/Makefile.in
--- dtach-0.8.orig/Makefile.in	2008-01-31 00:59:54.000000000 -0500
+++ dtach-0.8/Makefile.in	2010-07-27 11:04:43.000000000 -0400
@@ -4,16 +4,21 @@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 VERSION = @PACKAGE_VERSION@
 VPATH = $(srcdir)
 
 OBJ = attach.o master.o main.o
 SRC = $(srcdir)/attach.c $(srcdir)/master.c $(srcdir)/main.c
 
+ifeq (@enable_parser@, yes)
+	OBJ += parser.o
+	SRC += parser.c
+endif
+
 TARFILES = $(srcdir)/README $(srcdir)/COPYING $(srcdir)/Makefile.in \
 	   $(srcdir)/config.h.in $(SRC) \
 	   $(srcdir)/dtach.h $(srcdir)/dtach.spec $(srcdir)/configure \
 	   $(srcdir)/configure.ac $(srcdir)/dtach.1
 
 dtach: $(OBJ)
 	$(CC) -o $@ $(LDFLAGS) $(OBJ) $(LIBS)
 
diff -rNU8 -x configure -x config.h.in dtach-0.8.orig/configure.ac dtach-0.8/configure.ac
--- dtach-0.8.orig/configure.ac	2008-01-31 00:59:54.000000000 -0500
+++ dtach-0.8/configure.ac	2010-07-27 11:04:43.000000000 -0400
@@ -27,10 +27,20 @@
 AC_TYPE_PID_T
 
 # Checks for library functions.
 AC_TYPE_SIGNAL
 AC_CHECK_FUNCS(atexit dup2 memset)
 AC_CHECK_FUNCS(select socket strerror)
 AC_CHECK_FUNCS(openpty forkpty ptsname grantpt unlockpt)
 
+# Check to see if parser is being configured in
+AC_ARG_ENABLE(parser,
+	      AS_HELP_STRING([--enable-parser], [Enables a minimal terminal sequence parser]))
+AS_IF([test "x$enable_parser" = "xyes"], [
+       AC_SEARCH_LIBS(tigetstr, ncurses curses, [] ,
+		      [AC_MSG_FAILURE([Could not find curses library])])
+       AC_DEFINE(PARSER, 1, [Define to enable minimal terminal sequence parser.])
+])
+AC_SUBST(enable_parser)
+
 AC_CONFIG_FILES(Makefile)
 AC_OUTPUT
diff -rNU8 -x configure -x config.h.in dtach-0.8.orig/dtach.h dtach-0.8/dtach.h
--- dtach-0.8.orig/dtach.h	2008-01-31 00:59:54.000000000 -0500
+++ dtach-0.8/dtach.h	2010-07-27 13:33:29.000000000 -0400
@@ -129,8 +129,40 @@
 
 int attach_main(int noerror);
 int master_main(char **argv, int waitattach);
 
 #ifdef sun
 #define BROKEN_MASTER
 #endif
 #endif
+
+/* The pty struct - The pty information is stored here. */
+struct pty
+{
+	/* File descriptor of the pty */
+	int fd;
+#ifdef BROKEN_MASTER
+	/* File descriptor of the slave side of the pty. For broken systems. */
+	int slave;
+#endif
+	/* Process id of the child. */
+	pid_t pid;
+	/* The terminal parameters of the pty. Old and new for comparision
+	** purposes. */
+	struct termios term;
+	/* The current window size of the pty. */
+	struct winsize ws;
+	/* Buffer for I/O. */
+	char buf[BUFSIZE];
+#ifdef PARSER
+	/* Number of characters left in buffer. */
+	int leftover;
+	/* Keypad mode */
+	int smkx;
+#endif
+};
+
+#ifdef PARSER
+int parser_init(struct pty *p);
+int parse_buf(struct pty *p, unsigned int count, unsigned int *rem);
+int restore_state(struct pty *p, int fd);
+#endif
diff -rNU8 -x configure -x config.h.in dtach-0.8.orig/master.c dtach-0.8/master.c
--- dtach-0.8.orig/master.c	2008-01-31 00:59:54.000000000 -0500
+++ dtach-0.8/master.c	2010-07-27 13:33:33.000000000 -0400
@@ -13,34 +13,16 @@
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 #include "dtach.h"
 
-/* The pty struct - The pty information is stored here. */
-struct pty
-{
-	/* File descriptor of the pty */
-	int fd;
-#ifdef BROKEN_MASTER
-	/* File descriptor of the slave side of the pty. For broken systems. */
-	int slave;
-#endif
-	/* Process id of the child. */
-	pid_t pid;
-	/* The terminal parameters of the pty. Old and new for comparision
-	** purposes. */
-	struct termios term;
-	/* The current window size of the pty. */
-	struct winsize ws;
-};
-
 /* A connected client */
 struct client
 {
 	/* The next client in the linked list. */
 	struct client *next;
 	/* The previous client in the linked list. */
 	struct client **pprev;
 	/* File descriptor of the client. */
@@ -214,39 +196,55 @@
 	return s;
 }
 
 /* Process activity on the pty - Input and terminal changes are sent out to
 ** the attached clients. If the pty goes away, we die. */
 static void
 pty_activity(int s)
 {
-	unsigned char buf[BUFSIZE];
 	int len;
 	struct client *p;
 	fd_set readfds, writefds;
 	int highest_fd, nclients;
 
+#ifdef PARSER
+	int rlen;
+	unsigned int rem;
+
+	/* Read the pty activity */
+	rlen = read(the_pty.fd, the_pty.buf + the_pty.leftover,
+			sizeof(the_pty.buf) - the_pty.leftover);
+
+	/* Error -> die */
+	if (rlen <= 0)
+		exit(1);
+#else
 	/* Read the pty activity */
-	len = read(the_pty.fd, buf, sizeof(buf));
+	len = read(the_pty.fd, the_pty.buf, sizeof(the_pty.buf));
 
 	/* Error -> die */
 	if (len <= 0)
 		exit(1);
+#endif
 
 #ifdef BROKEN_MASTER
 	/* Get the current terminal settings. */
 	if (tcgetattr(the_pty.slave, &the_pty.term) < 0)
 		exit(1);
 #else
 	/* Get the current terminal settings. */
 	if (tcgetattr(the_pty.fd, &the_pty.term) < 0)
 		exit(1);
 #endif
 
+#ifdef PARSER
+	len = parse_buf(&the_pty, rlen, &rem);
+#endif
+
 top:
 	/*
 	** Wait until at least one client is writable. Also wait on the control
 	** socket in case a new client tries to connect.
 	*/
 	FD_ZERO(&readfds);
 	FD_ZERO(&writefds);
 	FD_SET(s, &readfds);
@@ -271,17 +269,18 @@
 		int written;
 
 		if (!FD_ISSET(p->fd, &writefds))
 			continue;
 
 		written = 0;
 		while (written < len)
 		{
-			int n = write(p->fd, buf + written, len - written);
+			int n = write(p->fd, the_pty.buf + written,
+					len - written);
 
 			if (n > 0)
 			{
 				written += n;
 				continue;
 			}
 			else if (n < 0 && errno == EINTR)
 				continue;
@@ -291,16 +290,21 @@
 		}
 		if (nclients != -1 && written == len)
 			nclients++;
 	}
 
 	/* Try again if nothing happened. */
 	if (!FD_ISSET(s, &readfds) && nclients == 0)
 		goto top;
+#ifdef PARSER
+	/* Move any leftover bytes to the front of the buffer */
+	memmove(the_pty.buf, the_pty.buf + the_pty.leftover + rlen - rem, rem);
+	the_pty.leftover = rem;
+#endif
 }
 
 /* Process activity on the control socket */
 static void
 control_activity(int s)
 {
 	int fd;
 	struct client *p;
@@ -319,16 +323,18 @@
 	p = malloc(sizeof(struct client));
 	p->fd = fd;
 	p->attached = 0;
 	p->pprev = &clients;
 	p->next = *(p->pprev);
 	if (p->next)
 		p->next->pprev = &p->next;
 	*(p->pprev) = p;
+
+	restore_state(&the_pty, fd);
 }
 
 /* Process activity from a client. */
 static void
 client_activity(struct client *p)
 {
 	int len;
 	struct packet pkt;
@@ -432,16 +438,26 @@
 	/* Create a pty in which the process is running. */
 	if (init_pty(argv, statusfd) < 0)
 	{
 		if (statusfd != -1)
 			dup2(statusfd, 1);
 		printf("%s: init_pty: %s\n", progname, strerror(errno));
 		exit(1);
 	}
+
+#ifdef PARSER
+	if (parser_init(&the_pty))
+	{
+		if (statusfd != -1)
+			dup2(statusfd, 1);
+		printf("%s: parser_init failed\n", progname);
+		exit(1);
+	}
+#endif
 	
 	/* Close statusfd, since we don't need it anymore. */
 	if (statusfd != -1)
 		close(statusfd);
 
 	/* Make sure stdin/stdout/stderr point to /dev/null. We are now a
 	** daemon. */
 	nullfd = open("/dev/null", O_RDWR);
diff -rNU8 -x configure -x config.h.in dtach-0.8.orig/parser.c dtach-0.8/parser.c
--- dtach-0.8.orig/parser.c	1969-12-31 19:00:00.000000000 -0500
+++ dtach-0.8/parser.c	2010-07-27 13:32:19.000000000 -0400
@@ -0,0 +1,242 @@
+#include <string.h>
+#include <stdlib.h>
+#include <curses.h>
+#include <term.h>
+
+#include "dtach.h"
+
+enum
+{
+	MATCH_DELETE = 0,
+	MATCH_SMKX = 1,
+	MATCH_RMKX = 2,
+};
+
+struct needle
+{
+	struct needle *next;
+	char *str;
+	short *table;
+	short j;
+	unsigned short action;
+};
+
+/*
+** Set up common answerback needles. Since none has any KMP fallback matches, we
+** can use the same table for all of them.
+*/
+static short anstables[] = {-1, 0, 0, 0, 0};
+static struct needle ans4 = {
+	.next = NULL,
+	.str = "\033[>0c",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans3 = {
+	.next = &ans4,
+	.str = "\033[>c",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans2 = {
+	.next = &ans3,
+	.str = "\033[c",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans1 = {
+	.next = &ans2,
+	.str = "\033Z",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle ans0 = {
+	.next = &ans1,
+	.str = "\005",
+	.table = anstables,
+	.j = 0,
+	.action = MATCH_DELETE,
+};
+static struct needle smkx = {
+	.next = NULL,
+	.str = NULL,
+	.table = NULL,
+	.j = 0,
+	.action = MATCH_SMKX,
+};
+static struct needle rmkx = {
+	.next = NULL,
+	.str = NULL,
+	.table = NULL,
+	.j = 0,
+	.action = MATCH_RMKX,
+};
+
+static struct needle *pincushion = &ans0, *pctail = &ans4;
+
+/*
+** Sets up the KMP fallback table for a needle.  Note that the table must be
+** allocated already.
+*/
+static void kmp_setup(struct needle *n)
+{
+	short i, j;
+
+	for (i = 0, j = -2; n->str[i]; i++)
+	{
+		while (j >= 0 && n->str[i - 1] != n->str[j])
+			j = n->table[j];
+		n->table[i] = ++j;
+	}
+}
+
+/*
+** Initializes the parser.
+*/
+int parser_init(struct pty *p)
+{
+	p->leftover = 0;
+	p->smkx = 0;
+	if (setupterm(NULL, p->fd, NULL) == ERR)
+		return 1;
+
+	smkx.str = tigetstr("smkx");
+	if (smkx.str)
+	{
+		smkx.table = malloc(strlen(smkx.str) * sizeof (int));
+		if (!smkx.table)
+			return 1;
+		kmp_setup(&smkx);
+		pctail->next = &smkx;
+		pctail = &smkx;
+	}
+	rmkx.str = tigetstr("rmkx");
+	if (rmkx.str)
+	{
+		rmkx.table = malloc(strlen(rmkx.str) * sizeof (int));
+		if (!rmkx.table)
+			return 1;
+		kmp_setup(&rmkx);
+		pctail->next = &rmkx;
+		pctail = &rmkx;
+	}
+	return 0;
+}
+
+/*
+** When successful, returns first needle found in haystack and places the index
+** right after the needle in next.  Otherwise, returns NULL and places count in
+** next.
+**
+** NOTE: This function is not generic in that it returns immediately when a
+** match is found.  This leaves the pincushion's j-values in an inconsistent
+** state, since the remaining needles for that pass have not been processed.  We
+** clear the j-values on a match, so this doesn't hurt here.
+*/
+static struct needle *kmp_search(const char *haystack, unsigned int count,
+		int *next)
+{
+	unsigned int i;
+	struct needle *n;
+
+	for (i = 0; i < count; i++)
+	{
+		for (n = pincushion; n; n = n->next)
+		{
+			while (n->j >= 0 && haystack[i] != n->str[n->j])
+				n->j = n->table[n->j];
+			if (!n->str[++n->j])
+			{
+				/* Found a match */
+				*next = i + 1;
+				return n;
+			}
+		}
+	}
+	/* Reached end with no match (i == count) */
+	*next = count;
+	return NULL;
+}
+
+/*
+** Process as much of the buffer as possible, rewriting it in place.  Returns
+** the new length of the buffer.  Puts the number of leftover bytes in rem.
+*/
+int parse_buf(struct pty *p, unsigned int count, unsigned int *rem)
+{
+	/* where to put good characters */
+	char *end;
+	/* next character being examined */
+	char *next;
+	struct needle *n;
+	int i, c;
+
+	end = next = p->buf + p->leftover;
+	while ((n = kmp_search(next, count, &i)))
+	{
+		/* c is number of "good" characters to append to buffer */
+		c = i;
+		switch (n->action)
+		{
+			case MATCH_DELETE:
+				c -= n->j;
+				break;
+			case MATCH_SMKX:
+				p->smkx = 1;
+				break;
+			case MATCH_RMKX:
+				p->smkx = 0;
+				break;
+		}
+		if (c > 0)
+			memmove(end, next, c);
+		end += c;
+		count -= i;
+		next += i;
+		for (n = pincushion; n; n = n->next)
+			n->j = 0;
+	}
+	/* Here c is number of potentially "bad" characters at end of buffer */
+	c = 0;
+	for (n = pincushion; n; n = n->next)
+		if (n->j > c)
+			c = n->j;
+	/* When kmp_search fails, i is set to count */
+	i -= c;
+	if (i > 0)
+		memmove(end, next, i);
+	end += i;
+	*rem = c;
+	return end - p->buf;
+}
+
+/*
+** Restores the state of a pty by replaying control sequences to the given fd.
+*/
+int restore_state(struct pty *p, int fd)
+{
+	int len, written, n;
+
+	if (p->smkx)
+	{
+		len = strlen(smkx.str);
+		n = 0;
+		for (written = 0; written < len; written += n)
+		{
+			n = write(fd, smkx.str + written, len - written);
+			if (n <= 0)
+			{
+				if (n == 0 || errno == EAGAIN)
+					break;
+				if (errno != EINTR)
+					return errno;
+				n = 0;
+			}
+		}
+	}
+	return 0;
+}
