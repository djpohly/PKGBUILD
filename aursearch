#!/bin/bash
# shellcheck disable=SC2016
readonly argv0=aursearch
readonly aurweb='https://aur.archlinux.org'
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -o pipefail

split_info() {
    awk -v rpc="$aurweb/rpc/?v=5&type=info" '{
        if (NR == 1)
            printf "%s&arg[]=%s", rpc, $0
        else if (NR % 150 == 0)
            printf "\n%s&arg[]=%s", rpc, $0
        else if (NR > 1)
            printf "&arg[]=%s", $0
    } END {
        printf "\n"
    }'
}

dl_stdin() {
    if type -P aria2c >/dev/null 2>&1; then
        aria2c --download-result=hide --console-log-level=error --stderr=true -d "$tmp"/aria2 -i - && cat "$tmp"/aria2/*
    elif type -P parallel >/dev/null 2>&1; then
        parallel --will-cite -X -j +8 --nice 10 --halt soon,fail=1 -r curl -fgLsS --compressed --cert-status {}
    else
        xargs -I{} -r curl -fgLsS --compressed --cert-status {}
    fi
}

getjson() {
    dl_stdin >"$1" || exit

    # https://lists.archlinux.org/pipermail/aur-dev/2016-October/004143.html
    sed 's/^/[/; s/}{/},{/g; s/$/]/' "$1"
}

json_short() {
    jq -e -r '[.[].results[]] | sort_by(.Name)[] | .Name,
        .Version,
        .NumVotes,
        .Description' | while
    {
        read -r Name
        read -r Version
        read -r NumVotes
        read -r Description
    }; do
        printf "${BLUE}aur/${ALL_OFF}${BOLD}%s ${GREEN}%s ${ALL_OFF}(%s)\n    %s\n" \
               "$Name" "$Version" "$NumVotes" "$Description"
    done
}

json_long() {
    jq -e -r '[.[].results[]] | sort_by(.Name)[] | .Name,
        .PackageBase,
        .Version,
        .Description,
        .URL,
        .NumVotes,
        .Popularity,
        .OutOfDate,
        .Maintainer,
        .FirstSubmitted,
        .LastModified' | while
    {
        read -r Name
        read -r PackageBase
        read -r Version
        read -r Description
        read -r URL
        read -r NumVotes
        read -r Popularity
        read -r OutOfDate
        read -r Maintainer
        read -r FirstSubmitted
        read -r LastModified
    }; do
        printf "Name:            %s\n" "$Name"
        printf "Base:            %s\n" "$PackageBase"
        printf "Version:         %s\n" "$Version"
        printf "Description:     %s\n" "$Description"
        printf "URL:             %s\n" "$URL"
        printf "Votes:           %s\n" "$NumVotes"
        printf "Popularity:      %s\n" "$Popularity"
        printf "Out Of Date:     %s\n" "$OutOfDate"
        printf "Maintainer:      %s\n" "$Maintainer"
        printf "First Submitted: %s\n" "$(date -d @"$FirstSubmitted" '+%c')"
        printf "Last Modified:   %s\n" "$(date -d @"$LastModified" '+%c')"
        printf '\n'
    done
}

regexp() {
    declare list=$1 aurgrep_args pattern
    shift

    if [[ $list == base ]]; then
        aurgrep_args+=(-b --)
    fi

    for pattern; do
        aurgrep_args+=(-e "$pattern")
    done

    aurgrep "${aurgrep_args[@]}"
}

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}

usage() {
    plain "usage: $argv0 [-PFbrvmn]"
    exit 1
}

readonly -f split_info dl_stdin getjson json_short json_long regexp trap_exit usage

source /usr/share/makepkg/util.sh || exit

if [[ -t 2 ]]; then
    colorize
fi

parse() { json_short; }
by=name-desc

while getopts :PFbrvmn OPT; do
    case $OPT in
        P) match() { regexp name "$@"; }
           by=none ;;
        b) match() { regexp base "$@"; }
           by=none ;;
        F) match() { printf '%s\n' "$@"; }
           by=none ;;
        m) by=maintainer ;;
        n) by=name ;;
        r) parse() { tee; } ;;
        v) parse() { json_long; } ;;
        *) usage ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

if ((!$#)); then
    usage
fi

tmp=$(mktemp -dt "$argv0".XXXXXXXX) || exit
trap 'trap_exit' EXIT

if [[ $by != none ]]; then
    printf '%s\n' "$@" | jq -R -r '@uri' | xargs printf \
        "$aurweb/rpc/?v=5&type=search&by=$by&arg=%s\n"
else
    match "$@" | jq -R -r '@uri' | split_info
fi | getjson "$tmp"/out.json | parse

# vim: set et sw=4 sts=4 ft=sh:
