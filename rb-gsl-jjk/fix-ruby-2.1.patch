diff --git a/ext/linalg.c b/ext/linalg.c
index 58a54a4..ea035fe 100644
--- a/ext/linalg.c
+++ b/ext/linalg.c
@@ -15,6 +15,12 @@
 #include "rb_gsl_common.h"
 #include "rb_gsl_linalg.h"
 
+struct RBasicRaw {
+    VALUE flags;
+    VALUE klass;
+};
+#define RBASIC_SET_CLASS(obj, cls)     do {((struct RBasicRaw *)(obj))->klass = cls; } while (0)
+
 static VALUE cgsl_matrix_LU;
 static VALUE cgsl_matrix_QR;
 static VALUE cgsl_matrix_QRPT;
@@ -71,7 +77,7 @@ static VALUE rb_gsl_linalg_LU_decomposition(int argc, VALUE *argv, VALUE obj, in
   Data_Get_Struct(omatrix, gsl_matrix, mtmp);
   if (flag == LINALG_DECOMP_BANG) {
     m = mtmp;
-    RBASIC(omatrix)->klass = cgsl_matrix_LU;
+    RBASIC_SET_CLASS(omatrix, cgsl_matrix_LU);
     objm = omatrix;
   } else {
     m = make_matrix_clone(mtmp);
@@ -693,7 +699,7 @@ static VALUE rb_gsl_linalg_QR_LQ_decomposition(int argc, VALUE *argv, VALUE obj,
     fdecomp = &gsl_linalg_QR_decomp;
     m = mtmp;
     mdecomp = omatrix;
-    RBASIC(mdecomp)->klass = cgsl_matrix_QR;
+    RBASIC_SET_CLASS(mdecomp, cgsl_matrix_QR);
     break;
 #ifdef GSL_1_6_LATER
   case LINALG_LQ_DECOMP:
@@ -705,7 +711,7 @@ static VALUE rb_gsl_linalg_QR_LQ_decomposition(int argc, VALUE *argv, VALUE obj,
     fdecomp = &gsl_linalg_LQ_decomp;
     m = mtmp;
     mdecomp = omatrix;
-    RBASIC(mdecomp)->klass = cgsl_matrix_LQ;
+    RBASIC_SET_CLASS(mdecomp, cgsl_matrix_LQ);
     break;
 #endif
   default:
@@ -733,7 +739,7 @@ static VALUE rb_gsl_linalg_QR_LQ_decomposition(int argc, VALUE *argv, VALUE obj,
       vtau = Data_Wrap_Struct(cgsl_vector_tau, 0, gsl_vector_free, tau);
       return rb_ary_new3(2, mdecomp, vtau);
     } else {
-      RBASIC(argv[itmp])->klass = cgsl_vector_tau;
+      RBASIC_SET_CLASS(argv[itmp], cgsl_vector_tau);
       return mdecomp;
     }
     break;
@@ -742,7 +748,7 @@ static VALUE rb_gsl_linalg_QR_LQ_decomposition(int argc, VALUE *argv, VALUE obj,
    if (argc == itmp) {
       return Data_Wrap_Struct(cgsl_vector_tau, 0, gsl_vector_free, tau);
     } else {
-      RBASIC(argv[itmp])->klass = cgsl_vector_tau;
+      RBASIC_SET_CLASS(argv[itmp], cgsl_vector_tau);
       return INT2FIX(status);
     }
     break;
@@ -1635,14 +1641,14 @@ static VALUE rb_gsl_linalg_QRLQPT_decomp_bang(int argc, VALUE *argv, VALUE obj,
   norm = gsl_vector_alloc(size0);
   switch (flag) {
   case LINALG_QRPT:
-    RBASIC(vA)->klass = cgsl_matrix_QRPT;
+    RBASIC_SET_CLASS(vA, cgsl_matrix_QRPT);
     vtau = Data_Wrap_Struct(cgsl_vector_tau, 0, gsl_vector_free, tau);
     vp = Data_Wrap_Struct(cgsl_permutation, 0, gsl_permutation_free, p);
     gsl_linalg_QRPT_decomp(A, tau, p, &signum, norm);
     break;
 #ifdef GSL_1_6_LATER
   case LINALG_PTLQ:
-    RBASIC(vA)->klass = cgsl_matrix_PTLQ;
+    RBASIC_SET_CLASS(vA, cgsl_matrix_PTLQ);
     vtau = Data_Wrap_Struct(cgsl_vector_tau, 0, gsl_vector_free, tau);
     vp = Data_Wrap_Struct(cgsl_permutation, 0, gsl_permutation_free, p);
     gsl_linalg_PTLQ_decomp(A, tau, p, &signum, norm);
diff --git a/ext/linalg_complex.c b/ext/linalg_complex.c
index 58d8762..f7199d8 100644
--- a/ext/linalg_complex.c
+++ b/ext/linalg_complex.c
@@ -15,6 +15,12 @@
 #include "rb_gsl_common.h"
 #include "rb_gsl_linalg.h"
 
+struct RBasicRaw {
+    VALUE flags;
+    VALUE klass;
+};
+#define RBASIC_SET_CLASS(obj, cls)     do {((struct RBasicRaw *)(obj))->klass = cls; } while (0)
+
 EXTERN VALUE mgsl_linalg;
 EXTERN VALUE cgsl_complex;
 
@@ -51,8 +57,8 @@ VALUE rb_gsl_linalg_complex_LU_decomp(int argc, VALUE *argv, VALUE obj)
   case 0:
     p = gsl_permutation_alloc(size);
     gsl_linalg_complex_LU_decomp(m, p, &signum);
-    if (itmp == 1) RBASIC(argv[0])->klass = cgsl_matrix_complex_LU;
-    else RBASIC(obj)->klass = cgsl_matrix_complex_LU;
+    if (itmp == 1) RBASIC_SET_CLASS(argv[0], cgsl_matrix_complex_LU);
+    else RBASIC_SET_CLASS(obj, cgsl_matrix_complex_LU);
     obj2 = Data_Wrap_Struct(cgsl_permutation, 0, gsl_permutation_free, p);
     return rb_ary_new3(2, obj2, INT2FIX(signum));
     break;
@@ -60,8 +66,8 @@ VALUE rb_gsl_linalg_complex_LU_decomp(int argc, VALUE *argv, VALUE obj)
     CHECK_PERMUTATION(argv[itmp]);
     Data_Get_Struct(argv[itmp], gsl_permutation, p);
     gsl_linalg_complex_LU_decomp(m, p, &signum);
-    if (itmp == 1) RBASIC(argv[0])->klass = cgsl_matrix_complex_LU;
-    else RBASIC(obj)->klass = cgsl_matrix_complex_LU;
+    if (itmp == 1) RBASIC_SET_CLASS(argv[0], cgsl_matrix_complex_LU);
+    else RBASIC_SET_CLASS(obj, cgsl_matrix_complex_LU);
     return INT2FIX(signum);
     break;
   default:
diff --git a/ext/vector_complex.c b/ext/vector_complex.c
index f9a84f0..c6bc248 100644
--- a/ext/vector_complex.c
+++ b/ext/vector_complex.c
@@ -12,6 +12,12 @@
 #include "rb_gsl_array.h"
 #include "rb_gsl_complex.h"
 
+struct RBasicRaw {
+    VALUE flags;
+    VALUE klass;
+};
+#define RBASIC_SET_CLASS(obj, cls)     do {((struct RBasicRaw *)(obj))->klass = cls; } while (0)
+
 EXTERN VALUE cgsl_complex;
 static VALUE rb_gsl_vector_complex_inner_product(int argc, VALUE *argv, VALUE obj);
 static VALUE rb_gsl_vector_complex_product_to_m(int argc, VALUE *argv, VALUE obj);
@@ -939,9 +945,9 @@ static VALUE rb_gsl_vector_complex_trans(VALUE obj)
 static VALUE rb_gsl_vector_complex_trans2(VALUE obj)
 {
   if (CLASS_OF(obj) == cgsl_vector_complex) 
-    RBASIC(obj)->klass = cgsl_vector_complex_col;
+    RBASIC_SET_CLASS(obj, cgsl_vector_complex_col);
   else if (CLASS_OF(obj) == cgsl_vector_complex_col) 
-    RBASIC(obj)->klass = cgsl_vector_complex;
+    RBASIC_SET_CLASS(obj, cgsl_vector_complex);
   else {
     rb_raise(rb_eRuntimeError, "method trans! for %s is forbidden",
 	     rb_class2name(CLASS_OF(obj)));
@@ -1986,6 +1992,34 @@ static VALUE rb_gsl_vector_complex_zip(int argc, VALUE *argv, VALUE obj)
   return ary;
 }
 
+
+#ifdef GSL_1_15_LATER
+
+/* GSL 1.15 and later already have a gsl_vector_complex_equal function. */
+
+static VALUE rb_gsl_vector_complex_equal(int argc, VALUE *argv, VALUE obj)
+{
+  gsl_vector_complex *v1, *v2;
+  int ret;
+  switch (argc) {
+  case 1:
+    break;
+  default:
+    rb_raise(rb_eArgError, "Wrong number of arguments (%d for 1)\n", argc);
+  }
+  Data_Get_Struct(obj, gsl_vector_complex, v1);
+  CHECK_VECTOR_COMPLEX(argv[0]);
+  Data_Get_Struct(argv[0], gsl_vector_complex, v2);
+  ret = gsl_vector_complex_equal(v1, v2);
+  if (ret == 1) return Qtrue;
+  else return Qfalse;
+}
+
+#else
+
+/* GSL 1.14 and earlier do not have a gsl_vector_complex_equal function. We need
+ * to provide our own implementation for it. */
+
 static int gsl_vector_complex_equal(const gsl_vector_complex *v1,
   const gsl_vector_complex *v2, double eps)
 {
@@ -2024,6 +2058,8 @@ static VALUE rb_gsl_vector_complex_equal(int argc, VALUE *argv, VALUE obj)
   else return Qfalse;
 }
 
+#endif
+
 static VALUE rb_gsl_vector_complex_not_equal(int argc, VALUE *argv, VALUE obj)
 {
   VALUE ret;
diff --git a/ext/vector_source.c b/ext/vector_source.c
index 1bb9ce9..a60bc77 100644
--- a/ext/vector_source.c
+++ b/ext/vector_source.c
@@ -36,6 +36,15 @@
 #define VEC_VIEW_P VECTOR_INT_VIEW_P
 #endif
 
+#ifndef jjk
+#define jjk
+struct RBasicRaw {
+    VALUE flags;
+    VALUE klass;
+};
+#endif
+#define RBASIC_SET_CLASS(obj, cls)     do {((struct RBasicRaw *)(obj))->klass = cls; } while (0)
+
 void FUNCTION(get_range,beg_en_n)(VALUE range, BASE *beg, BASE *en, size_t *n, int *step);
 
 void get_range_beg_en_n_for_size(VALUE range,
@@ -673,15 +682,15 @@ static VALUE FUNCTION(rb_gsl_vector,trans)(VALUE obj)
 static VALUE FUNCTION(rb_gsl_vector,trans_bang)(VALUE obj)
 {
 #ifdef BASE_DOUBLE
-  if (CLASS_OF(obj) == cgsl_vector) RBASIC(obj)->klass = cgsl_vector_col;
-  else if (CLASS_OF(obj) == cgsl_vector_col) RBASIC(obj)->klass = cgsl_vector;
+  if (CLASS_OF(obj) == cgsl_vector) RBASIC_SET_CLASS(obj, cgsl_vector_col);
+  else if (CLASS_OF(obj) == cgsl_vector_col) RBASIC_SET_CLASS(obj, cgsl_vector);
   else {
     rb_raise(rb_eRuntimeError, "method trans! for %s is not permitted.",
 	     rb_class2name(CLASS_OF(obj)));
   }	
 #elif defined(BASE_INT)
-  if (CLASS_OF(obj) == cgsl_vector_int) RBASIC(obj)->klass = cgsl_vector_int_col;
-  else if (CLASS_OF(obj) == cgsl_vector_int_col) RBASIC(obj)->klass = cgsl_vector_int;
+  if (CLASS_OF(obj) == cgsl_vector_int) RBASIC_SET_CLASS(obj, cgsl_vector_int_col);
+  else if (CLASS_OF(obj) == cgsl_vector_int_col) RBASIC_SET_CLASS(obj, cgsl_vector_int);
   else {
     rb_raise(rb_eRuntimeError, "method trans! for %s is not permitted.",
 	     rb_class2name(CLASS_OF(obj)));
