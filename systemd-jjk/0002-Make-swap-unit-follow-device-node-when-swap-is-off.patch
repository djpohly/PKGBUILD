From c37dc4907105efcf8fa73933d308a8e8bea065a5 Mon Sep 17 00:00:00 2001
From: Olivier Brunel <i.am.jack.mail@gmail.com>
Date: Mon, 29 Oct 2012 16:44:30 +0100
Subject: [PATCH 2/3] Make swap unit follow device node when swap is off

Swap units will now be following the unit of the devnode when the swap is off
(and usual following therefore not in place), thus allowing things to work
even in cases such as:
    systemctl start 'dev-disk-by\x2dlabel-SWAP.swap' dev-sda3.swap

This first will load and redirect the request to the unit for sda3, the second
will :
- if /dev/sda3 is what appears on /proc/swaps, be starting/started already
- else if swap is started, it'll follow the unit from /proc/swaps
- else it'll still be following dev-sda3.swap (which is starting)

Signed-off-by: Olivier Brunel <i.am.jack.mail@gmail.com>
---
 src/core/swap.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/src/core/swap.c b/src/core/swap.c
index 5d29377..6a57cfa 100644
--- a/src/core/swap.c
+++ b/src/core/swap.c
@@ -1152,6 +1152,7 @@ int swap_fd_event(Manager *m, int events) {
 static Unit *swap_following(Unit *u) {
         Swap *s = SWAP(u);
         Swap *other, *first = NULL;
+        struct udev_device *d = NULL;
 
         assert(s);
 
@@ -1172,6 +1173,49 @@ static Unit *swap_following(Unit *u) {
                 first = other;
         }
 
+        /* if we have nothing, let's try to follow the unit of the actual
+         * device and not any symlink */
+        if (!first) {
+            Manager *m = u->manager;
+            struct stat st;
+            const char *dn;
+
+            if (stat(s->what, &st) >= 0 && S_ISBLK(st.st_mode)) {
+                d = udev_device_new_from_devnum(m->udev, 'b', st.st_rdev);
+                if (!d)
+                    goto bail;
+
+                dn = udev_device_get_devnode(d);
+                if (dn && !streq(dn, s->what)) {
+                    Unit *f = NULL;
+                    int r;
+                    char *e;
+
+                    r = swap_add_one(m, dn, dn, s->parameters_proc_swaps.priority, false, false, false);
+                    if (r < 0)
+                        goto bail;
+
+                    e = unit_name_from_path(dn, ".swap");
+                    if (!e)
+                        goto bail;
+
+                    f = manager_get_unit(m, e);
+                    free(e);
+                    if (!f)
+                        goto bail;
+
+                    udev_device_unref(d);
+
+                    /* we need to load it now, else starting will fail */
+                    unit_load(f);
+                    return f;
+                }
+            }
+        }
+
+bail:
+        if (d)
+            udev_device_unref(d);
         return UNIT(first);
 }
 
-- 
1.8.0

