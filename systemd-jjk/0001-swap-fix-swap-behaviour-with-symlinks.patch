From 2e88ff964822af5f84fc6681fcfdf6d69d5c8802 Mon Sep 17 00:00:00 2001
From: Olivier Brunel <i.am.jack.mail@gmail.com>
Date: Sat, 13 Oct 2012 14:24:15 +0200
Subject: [PATCH 1/3] swap: fix swap behaviour with symlinks

Starting a swap unit pointing to (What) a symlink (e.g. /dev/mapper/swap
or /dev/disk/by-uuid/...) would have said unit marked active, following
the one using the "actual" device (/dev/{dm-1,sda3}), but that new unit
would be seen as inactive.
Since all requests to stop swap units would follow/redirect to it,
and it is seen inactive, nothing would be done (swapoff never called).

This is because this unit would be treated twice in
swap_process_new_swap, the second call to swap_add_one causing it to
eventually be marked inactive.

Signed-off-by: Olivier Brunel <i.am.jack.mail@gmail.com>
---
 src/core/swap.c | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/core/swap.c b/src/core/swap.c
index c708b7f..5d29377 100644
--- a/src/core/swap.c
+++ b/src/core/swap.c
@@ -415,7 +415,8 @@ static int swap_process_new_swap(Manager *m, const char *device, int prio, bool
                         return -ENOMEM;
 
                 dn = udev_device_get_devnode(d);
-                if (dn)
+                /* Skip dn==device, since that case will be handled below */
+                if (dn && !streq(dn, device))
                         r = swap_add_one(m, dn, device, prio, false, false, set_flags);
 
                 /* Add additional units for all symlinks */
@@ -433,9 +434,13 @@ static int swap_process_new_swap(Manager *m, const char *device, int prio, bool
                                 if ((!S_ISBLK(st.st_mode)) || st.st_rdev != udev_device_get_devnum(d))
                                         continue;
 
-                        k = swap_add_one(m, p, device, prio, false, false, set_flags);
-                        if (k < 0)
-                                r = k;
+                        /* Skip p==device, since that case will be handled below */
+                        if (!streq(p, device))
+                        {
+                            k = swap_add_one(m, p, device, prio, false, false, set_flags);
+                            if (k < 0)
+                                    r = k;
+                        }
                 }
 
                 udev_device_unref(d);
-- 
1.8.0

